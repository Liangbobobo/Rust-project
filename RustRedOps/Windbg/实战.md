# 实战示例

## 手动内存结构验证(notepad)

以notepad为例,验证内存中peb->ApiSetMap中涉及到的各个数据结构

### 思路

!peb //得到baseaddr
->dt ntdll!_PEB @$peb ApiSetMap //得到ApiSetMap地址范围,用于下个命令中的地址范围
->dd  0x00000202`65150000 L8 //得到API_SET_NAMESPACE结构体,其中第五个EntryOffset为entry的RVA
->dd baseaddr+entry(RVA) L6 //API_SET_NAMESPACE_ENTRY,代表第一个虚拟dll描述符,其中第二个代表名称字符串的RVA,第二个代表长度
->du Base +RVA(0x00000202`65150000+0xc880)//显示真正的字符产


 * 你的发现："api-ms-onecoreuap-print-render-l1-1-0kernel.appcore.dll..."
   * 现象解释：注意看，你看到的字符串后面紧接着 kernel.appcore.dll。这是因为
     ApiSetMap 为了节省内存，字符串是不以 NULL (`\0`)
     结尾的！它们紧密地挨在一起。
   * 如何切割：全靠上一层的 `NameLength`
     (0x4a)。你在代码中读取时，必须读取指定的长度，而不能像读 C 字符串那样读到 0
     为止。

  ---

  2. 结构体关系图解

  这三个结构体就像是俄罗斯套娃，或者更像是一个文件系统的目录结构。

    1 graph TD
    2     Base(ApiSetMap 基址) --> Header[API_SET_NAMESPACE 头部]
    3
    4     Header -- EntryOffset (0x98) --> EntryArray[Entry 数组]
    5
    6     subgraph Entries
    7     Entry1[Entry 1: api-ms-onecoreuap...]
    8     Entry2[Entry 2: api-ms-win-core...]
    9     Entry3[Entry 3: ...]
   10     end
   11
   12     EntryArray --> Entry1
   13
   14     Entry1 -- NameOffset (0xc880) --> NameString["api-ms-onecoreuap..."]
   15     Entry1 -- ValueOffset (0x5c90) --> ValueEntry[Value 数组]
   16
   17     ValueEntry -- ValueOffset --> HostString["...print.client.dll"]

  逻辑链条：
   1. 持有句柄：你拿到 PEB.ApiSetMap (设为 Base)。
   2. 定位数组：计算 Base + Header.EntryOffset，找到 Entry 数组的起点。
   3. 遍历查找：在数组中遍历。
   4. 定位名称：对于每个 Entry，计算 Base + Entry.NameOffset 找到名字。
   5. 读取名称：从那个位置读取 Entry.NameLength 长度的字节，与你想找的 DLL
      名字对比。
   6. 定位宿主：如果名字匹配，计算 Base + Entry.ValueOffset 找到宿主信息。

  ---

  3. 核心原理：为什么是“偏移量”而不是“指针”？

  你可能会问：为什么结构体里存的是 `0x98` (偏移)，而不是 `0x0000020265150098`
  (绝对地址)？

  这就是 Windows 内存设计的精妙之处（也是 PE 格式的通用逻辑）：

   1. 位置无关代码 (Position Independent)：整个 ApiSetMap
      数据块是一块连续的内存。它可以被操作系统随意映射到内存的任何位置（ASLR
      机制）。
   2. 相对寻址：如果内部使用绝对地址，一旦这块内存被移动，里面所有的指针都要修正
      （重定位），开销巨大。
   3. Offset 的好处：使用相对于 Base 的偏移量。无论这块内存被搬到哪里，Base +
      0x98 永远指向 Entry 数组。

  这直接决定了你 Rust 代码的写法：

   1 // 错误写法 (假设它是绝对指针)
   2 // let entry = header.EntryOffset as *const Entry;
   3
   4 // 正确写法 (基址 + 偏移)
   5 let base_addr = peb.ApiSetMap as usize;
   6 let entry_addr = base_addr + header.EntryOffset as usize;
   7 let entry = entry_addr as *const API_SET_NAMESPACE_ENTRY;

  总结

  你这次的操作非常成功，验证了以下事实：
   1. 结构体定义正确：Rust 中的 u32 字段完美对应了内存中的 4 字节数据。
   2. 版本确认：当前系统确实使用 Version 6 布局。
   3. 字符串特性：证实了 ApiSetMap
      中的字符串是非空结且紧密排列的，这提示我们在编写解析代码时必须依赖 Length
      字段，小心越界。

  现在，你可以放心地在 Rust 项目中实现 resolve_apiset_map 逻辑了。

### 进入准备

1. 按下 Win + R，输入 notepad，回车。这将启动一个记事本进程
2. 在windbg中,file->attach to process
3. 搜索框搜索notepad,选中notepad.exe
4. .symfix(下载符号) .reload(重载)

### 开始进入

- 查看 PEB 地址

记录peb地址:PEB at 00000039de081000 作为baseaddr

1. !peb  
2. dt ntdll!_PEB @$peb : 查看peb所有字段
3. dt ntdll!_PEB @$peb ApiSetMap : 只显示指定字段(这里显示该字段的地址 以及类型是Void,但我们清楚其实质上是API_SET_NAMESPACE)
4. dt ntdll!_API_SET_NAMESPACE 0x00000202`65150000

- 出现Symbol not found

```text
0:026> dt ntdll!_PEB @$peb ApiSetMap
   +0x068 ApiSetMap : 0x00000202`65150000 Void
0:026> dt ntdll!_API_SET_NAMESPACE 0x00000202`65150000
Symbol ntdll!_API_SET_NAMESPACE not found.
```

1. dd 0x00000202`65150000 L8

```rust
0:026> dd 0x00000202`65150000 L8
00000202`65150000  00000006 00029998 00000000 000003d5
00000202`65150010  00000098 0000a9ac 0000001f ff080007

#[repr(C)]
pub struct API_SET_NAMESPACE {
    pub Version: u32,
    pub Size: u32,
    pub Flags: u32,
    pub Count: u32,
    pub EntryOffset: u32,
    pub HashOffset: u32,
    pub HashFactor: u32
}
```

dd: Display DWORD (以 4 字节整数格式显示内存)  
L8: 显示 8 个数据（两行，每行 4 个数,每个数都是十六进制）

第一行:

1. 00000006 -> Version: 看到这个 6证明结构体是对的(Win10+ 是 v6)
2. 00005e8c -> Size: 整个 ApiSet 数据块的大小
3. 00000000 -> Flags: 标志位
4. 000001c6 -> Count: 虚拟 DLL 的数量（这里是 454 个）

第二行:

1. 0000007c -> EntryOffset: 第一个 Entry 距离头部的偏移量（124 字节）
2. 0000242c -> HashOffset: Hash 表的偏移量
3. 0000001f -> HashFactor: Hash 计算因子

### 进一步查看

如EntryOffset 是 0x7c,可以直接到目标地址查看  
baseaddr+0x7c

dd 0x00000202`65150000+0x7c L6

得到对应 API_SET_NAMESPACE_ENTRY的结构体










有些地方我不明白
1. dd 0x00000202`65150000 L8 得到的 00000006 这些数字是十六进制吗?是几个字节?是不是根据不同的平台而不同?
2. 怎么得到符号文件,让windbg直观的显示结构?或者有啥其他办法?