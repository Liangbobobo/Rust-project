- [关于汇编和PE文件的基础知识](#关于汇编和pe文件的基础知识)
  - [windows x86\_64架构下的寄存器](#windows-x86_64架构下的寄存器)
    - [RIP](#rip)
  - [本项目中/src/syscall/asm.rs涉及的基础知识](#本项目中srcsyscallasmrs涉及的基础知识)
    - [关于间接系统调用（Indirect Syscalls）](#关于间接系统调用indirect-syscalls)
  - [代码逐行解析](#代码逐行解析)
    - [保存非易失性寄存器](#保存非易失性寄存器)
  - [被调用者还需要其他非易失性寄存器来存储被调用者的信息吗？只需要这三个吗？](#被调用者还需要其他非易失性寄存器来存储被调用者的信息吗只需要这三个吗)
    - [mov eax, ecx mov r12, rdx mov rcx, r8](#mov-eax-ecx-mov-r12-rdx-mov-rcx-r8)
      - [为什么要执行 `mov r12, rdx`？](#为什么要执行-mov-r12-rdx)
      - [为什么要执行 `mov rcx, r8`？](#为什么要执行-mov-rcx-r8)
    - [总结](#总结)
    - [mov r10, r9 mov rdx,  \[rsp + 0x28\] mov r8,   \[rsp + 0x30\] mov r9,   \[rsp + 0x38\]](#mov-r10-r9-mov-rdx--rsp--0x28-mov-r8---rsp--0x30-mov-r9---rsp--0x38)
    - [这么倒腾寄存器的目的](#这么倒腾寄存器的目的)
      - [1. 技术层面：消除“包装函数”引入的偏差（“搬运工”）](#1-技术层面消除包装函数引入的偏差搬运工)
      - [2. 战术层面：实现“间接系统调用”（“隐身术”）](#2-战术层面实现间接系统调用隐身术)
    - [关于jmp rcx](#关于jmp-rcx)
      - [寄存器值追踪：`jmp rcx` 到底跳转到哪里？](#寄存器值追踪jmp-rcx-到底跳转到哪里)
        - [1. 代码开头：保存现场](#1-代码开头保存现场)
        - [2. 参数“乾坤大挪移”（关键步骤）](#2-参数乾坤大挪移关键步骤)
        - [3. 处理参数搬运（如果参数 \> 4）](#3-处理参数搬运如果参数--4)
        - [4. 恢复与准备跳转](#4-恢复与准备跳转)
        - [总结：为什么绕这么一大圈？](#总结为什么绕这么一大圈)
      - [参数重映射（核心逻辑）](#参数重映射核心逻辑)
      - [处理栈上参数（Arg5+）](#处理栈上参数arg5)
      - [执行跳转](#执行跳转)
  - [3. x86 (32-bit) 汇编简述](#3-x86-32-bit-汇编简述)
  - [总结](#总结-1)
  - [windows 64的软件与底层硬件的约定](#windows-64的软件与底层硬件的约定)
  - [被调用者还需要其他非易失性寄存器来存储被调用者的信息吗？只需要这三个吗？](#被调用者还需要其他非易失性寄存器来存储被调用者的信息吗只需要这三个吗-1)
    - [特殊情况区分：函数调用 vs 任务切换](#特殊情况区分函数调用-vs-任务切换)
    - [代码逻辑分析：为什么要碰这三个？](#代码逻辑分析为什么要碰这三个)
      - [A. 为什么保存 `RSI` 和 `RDI`？](#a-为什么保存-rsi-和-rdi)
      - [B. 为什么保存 `R12`？](#b-为什么保存-r12)
      - [C. 为什么不保存 `RBX`, `R13`, `R14`, `R15`？](#c-为什么不保存-rbx-r13-r14-r15)
    - [总结](#总结-2)
  - [`RSI`、`RDI`、`R12` 这三个寄存器能不能更改？](#rsirdir12-这三个寄存器能不能更改)
    - [寄存器选择的底层逻辑：硬件约束 vs 程序员自由](#寄存器选择的底层逻辑硬件约束-vs-程序员自由)
    - [`RSI` 和 `RDI`：硬件指令的“硬性绑定”（Hard Constraint）](#rsi-和-rdi硬件指令的硬性绑定hard-constraint)
      - [原因](#原因)
      - [替代方案的成本](#替代方案的成本)
    - [`R12`：程序员的“任意选择”（Soft Choice）](#r12程序员的任意选择soft-choice)
      - [原因](#原因-1)
      - [可选的替代寄存器](#可选的替代寄存器)
      - [演示：将 `R12` 替换为 `RBX`](#演示将-r12-替换为-rbx)

# 关于汇编和PE文件的基础知识

## windows x86_64架构下的寄存器

### RIP

RIP (Instruction Pointer) 是x86-64架构中的程序计数器（Program Counter）寄存器，它的作用是存储下一条要执行的指令的地址

作用:

1. 跟踪执行流程：RIP始终指向CPU将要执行的下一条指令的地址
2. 控制程序流程：通过修改RIP的值，可以改变程序的执行路径（如跳转、调用、返回等）

在windwos系统调用(syscall)中

1. 当执行syscall指令时，CPU会自动将当前RIP值（即下一条指令地址）保存到RCX寄存器
2. 在x86-64架构中，RIP寄存器不能被直接读取或写入(避免程序直接修改执行流程;保持指令执行的正确性和安全性).但可以通过jmp 指令：直接修改RIP（无条件跳转）;call 指令：将返回地址（RIP+指令长度）压入栈，然后修改RIP;ret 指令：从栈中弹出地址并加载到RIP来间接操作RIP

## 本项目中/src/syscall/asm.rs涉及的基础知识

### 关于间接系统调用（Indirect Syscalls）

在红队操作（RedOps）和 EDR 规避技术中，直接调用 Windows API（如 CreateFile）或甚至是底层的 NtCreateFile 都可能被安全软件（EDR/AV）在用户模式下挂钩（Hook）并监控。为了绕过这些监控，该代码实现了手动设置 CPU 寄存器并跳转到 ntdll.dll 中的 syscall 指令地址执行，从而避开函数入口处的 Hook。

```rust
extern "C" {
    pub fn do_syscall(
        ssn: u16,          // 参数 1 (rcx): 系统服务号 (System Service Number)
        syscall_addr: u64, // 参数 2 (rdx): syscall 指令的内存地址
        n_args: u32,       // 参数 3 (r8) : 实际系统调用的参数个数
        ...                // 参数 4+ (r9, stack): 实际传递给系统调用的参数 (arg1, arg2...)
    ) -> i32;
}
```

这个函数的签名非常特殊。它是一个“垫片”函数，负责接收参数，重新排列它们以符合 Windows 系统调用的内核约定，然后跳转执行。

do_syscall这个函数本身需要接收 3 个额外的控制参数，而这 3个参数霸占了本该属于系统调用参数的前三个寄存器位置。因此,需要将rdx r8 r9位移接收这三个参数.且ecx因为windows的调用约定,也需要改变.

[windows 64的软件与底层硬件的约定](#windows-64的软件与底层硬件的约定)

## 代码逐行解析

### 保存非易失性寄存器

```asm
do_syscall:
    mov [rsp - 0x8],  rsi
    mov [rsp - 0x10], rdi
    mov [rsp - 0x18], r12
```

这里非常规地将 `rsi`, `rdi`, `r12`（这些是“被调用者保存”的寄存器）保存到了栈顶下方（Shadow Space 区域或者更低）。这是为了在函数结束前恢复它们，保证不破坏调用者的环境。

> ✅ **关键点**：虽然 `rsi`/`rdi` 在 Windows x64 中不是标准 callee-saved 寄存器，但某些上下文（如 Rust 编译器生成的代码）可能依赖其值不变，因此保守保存。

[被调用者还需要其他非易失性寄存器来存储被调用者的信息吗？只需要这三个吗？](#被调用者还需要其他非易失性寄存器来存储被调用者的信息吗只需要这三个吗)
---

### mov eax, ecx mov r12, rdx mov rcx, r8

你的 Rust 函数签名：

```rust
pub fn do_syscall(ssn: u16, syscall_addr: u64, n_args: u32, ...)
```

根据 **Windows x64 ABI**，它只决定了**参数刚进入函数时的初始位置**：

```rust
pub fn do_syscall(
    ssn: u16,           // 参数 1 (RCX)
    syscall_addr: u64,  // 参数 2 (RDX)
    n_args: u32,        // 参数 3 (R8)
    arg1: u64,          // 参数 4 (R9)
    arg2: u64,          // 参数 5 (栈: RSP+0x28)
    arg3: u64,          // 参数 6 (栈: RSP+0x30)
    ...
)
```

Windows 系统调用底层（`syscall` 指令）要求的寄存器布局是：

| 目标用途 | 所需寄存器 | 值来源 |
|----------|------------|--------|
| 系统服务号（SSN） | `RAX` | 来自 `RCX` |
| 参数1 | `R10` | 来自 `R9` |
| 参数2 | `RDX` | 来自栈上 `[rsp + 0x28]` |
| 参数3 | `R8` | 来自栈上 `[rsp + 0x30]` |
| 参数4 | `R9` | 来自栈上 `[rsp + 0x38]` |

#### 为什么要执行 `mov r12, rdx`？

**原因：保护 `syscall_addr`（系统调用地址），因为 `RDX` 即将被覆盖。**

1. **冲突**：  
   进入函数时，`RDX` 寄存器里存放的是 `do_syscall` 的第 2 个参数，即 `syscall_addr`（你要跳转到的地址）。  
   但是，**实际的系统调用需要使用 `RDX` 来存放它的第 2 个参数**。

2. **解决**：  
   在将真正的第 2 个参数（从栈上取出的 `arg2`）放入 `RDX` 之前，必须先把 `syscall_addr` 备份到一个安全的地方。

3. **选择 `R12`**：  
   `R12` 是一个 **被调用者保存（Callee-saved / Non-volatile）** 非易失性寄存器。  
   代码开头已经把 `R12` 压栈保存了（例如 `mov [rsp - 0x18], r12`），所以用它来临时存储 `syscall_addr` 是安全的。  
   代码最后会执行 `mov rcx, r12` 然后 `jmp rcx` 来跳转到该地址。

---

#### 为什么要执行 `mov rcx, r8`？

**原因：腾出 `R8` 寄存器，并为 `rep movsq` 设置计数器。**

1. **冲突**：  
   进入函数时，`R8` 寄存器里存放的是 `do_syscall` 的第 3 个参数，即 `n_args`（参数个数）。  
   但**实际的系统调用需要使用 `R8` 来存放它的第 3 个参数**。

2. **准备计数器**：  
   代码后面有一段逻辑 `rep movsq`，用于当参数超过 4 个时，搬运栈上的剩余参数。  
   汇编指令 `rep`（repeat）依赖 **`RCX` 寄存器作为计数器（Counter）**。

3. **复用 `RCX`**：  
   刚进入函数时 `RCX` 存的是 `SSN`，但 `SSN` 已经被移到了 `EAX`（`mov eax, ecx`），所以 `RCX` 现在是空闲的。  
   将 `n_args` 从 `R8` 移到 `RCX`，既：
   - 腾出了 `R8` 给系统调用参数使用，
   - 又正好为后面的参数搬运循环设置好了计数器。

---

### 总结

这几行代码是在做一个“乾坤大挪移”，将 Rust 函数传进来的元数据（`SSN`、地址、数量）挪走，以便把寄存器（`RDX`、`R8`）腾出来给真正的系统调用参数使用。

### mov r10, r9 mov rdx,  [rsp + 0x28] mov r8,   [rsp + 0x30] mov r9,   [rsp + 0x38]

### 这么倒腾寄存器的目的

#### 1. 技术层面：消除“包装函数”引入的偏差（“搬运工”）

你的 Rust 函数 `do_syscall` 是一个包装器（Wrapper）。为了告诉这个包装器要做什么，你传给它 3 个元数据参数：

1. **SSN**（系统调用号，如 `0x18` for `NtAllocateVirtualMemory`）  
2. **Address**（你要跳转到的 `syscall` 指令的内存地址）  
3. **Count**（参数个数）

这导致了**参数位置的错位**：

- 真正的第 1 个参数（比如 `ProcessHandle`），本该在 `R10`，结果被挤到了 `R9`（因为前三个位置被元数据占了）。  
- 真正的第 2 个参数，本该在 `RDX`，结果被挤到了栈上。

汇编代码的目的就是把这些被“挤偏”了的参数，通过手动搬运，**复位到内核要求的标准位置上**。

| 逻辑参数        | 在 Wrapper 中的位置 (现状) | 内核要求的位置 (目标) | 汇编做的操作                        |
|-----------------|----------------------------|------------------------|-------------------------------------|
| 元数据：SSN     | `RCX`                      | `EAX`                  | `mov eax, ecx`（设置系统调用号）    |
| 元数据：Address | `RDX`                      | （用于跳转）           | `mov r12, rdx` … `jmp rcx`（准备跳转） |
| 元数据：Count   | `R8`                       | （用于循环）           | `mov rcx, r8`（用作 `rep movsq` 计数器） |
| 真实参数 1      | `R9`                       | `R10`                  | `mov r10, r9`（归位）               |
| 真实参数 2      | 栈 (`RSP+0x28`)            | `RDX`                  | `mov rdx, [rsp+0x28]`（归位）       |
| 真实参数 3      | 栈 (`RSP+0x30`)            | `R8`                   | `mov r8, [rsp+0x30]`（归位）        |
| 真实参数 4      | 栈 (`RSP+0x38`)            | `R9`                   | `mov r9, [rsp+0x38]`（归位）        |

> **一句话总结**：代码在执行“乾坤大挪移”，把 Rust 函数调用约定的布局，强行转换成 Windows 内核系统调用约定的布局。

---

#### 2. 战术层面：实现“间接系统调用”（“隐身术”）

如果只是为了调用内核函数，直接使用 Windows API（如 `OpenProcess`）或者直接写 `syscall` 指令也可以。为什么要搞这么复杂？

这里的**关键在于最后那句 `jmp rcx`**（其实是跳转到 `syscall_addr`）。

- **常规调用**：  
  程序调用 `kernel32.dll` → `ntdll.dll` → `syscall`。  
  EDR（端点检测响应系统）通常会在 `ntdll.dll` 的函数入口处挂钩（Hook），监控你的行为。

- **直接系统调用 (Direct Syscall)**：  
  你自己写汇编执行 `syscall` 指令。  
  EDR 可能会检测到 `syscall` 指令并非来自 `ntdll.dll` 的内存区域，从而报警（**RIP Sanity Check**）。

- **间接系统调用 (Indirect Syscall) —— 这段代码的目的**：
  1. 你先在 `ntdll.dll` 中找到一条**合法的 `syscall` 指令的地址**（这就是传入的 `syscall_addr`）。
  2. 你把参数全部准备好（就是上面做的寄存器转移）。
  3. 你**跳转（Jump）到 `ntdll.dll` 里的那个 `syscall` 指令去执行**。

> **最终目的**：  
> 当 `syscall` 指令执行进入内核时，内核检查调用栈，发现上一条指令确实是在合法的 `ntdll.dll` 里面执行的，于是**骗过了安全检查**，认为这是一个合法的系统调用，从而实现了红队操作中的**免杀 / Evasion**。

### 关于jmp rcx

#### 寄存器值追踪：`jmp rcx` 到底跳转到哪里？

这是一个容易让人眼花缭乱的地方，让我们回过头仔细追踪一下寄存器的值。

在 `do_syscall` 函数中，`jmp rcx` 实际上跳转到的是 **`syscall_addr`**（即系统调用指令在 `ntdll.dll` 中的内存地址）。

---

##### 1. 代码开头：保存现场

```asm
do_syscall:
    mov [rsp - 0x8],  rsi
    mov [rsp - 0x10], rdi
    mov [rsp - 0x18], r12  ; ← R12 被保存到栈上
```

- 此时 `RSI`、`RDI`、`R12` 的原始值被压入栈中，以遵守调用约定（Callee-saved）。

---

##### 2. 参数“乾坤大挪移”（关键步骤）

进入函数时的初始状态：

- `RCX` = `SSN`（参数1）  
- `RDX` = `syscall_addr`（参数2，**目标跳转地址！**）  
- `R8` = `n_args`（参数3）

执行以下操作：

```asm
    mov eax, ecx   ; EAX = SSN（供 syscall 使用）
    mov r12, rdx   ; R12 = syscall_addr ← 关键：目标地址被备份到 R12
    mov rcx, r8    ; RCX = n_args ← 用于后续 rep movsq 的计数器
```

✅ **此时状态**：
- `R12` 持有 `syscall_addr`
- `RCX` 持有 `n_args`（不再包含 SSN）

---

##### 3. 处理参数搬运（如果参数 > 4）

```asm
    sub rcx, 0x4   ; RCX = n_args - 4
    jle skip       ; 如果参数 ≤ 4，跳过搬运

    ; ... (rep movsq 搬运栈上多余参数) ...
    ; 这段使用 RCX 作为循环计数器
```

- `RCX` 在此过程中被消耗，最终变为 0 或负数。

---

##### 4. 恢复与准备跳转

```asm
skip:
    mov rcx, r12           ; ← 关键：把 syscall_addr 从 R12 移回 RCX
    mov rsi, [rsp - 0x8]   ; 恢复 RSI
    mov rdi, [rsp - 0x10]  ; 恢复 RDI
    mov r12, [rsp - 0x18]  ; 恢复 R12（遵守 Callee-saved 约定）
    jmp rcx                ; ← 跳转到 RCX，即 syscall_addr
```

> 注意顺序：**先将 `R12` 的内容移到 `RCX`，再恢复 `R12` 原值**。这样既保留了跳转地址，又满足了调用约定。

---

##### 总结：为什么绕这么一大圈？

1. **刚进来时**，`RDX` 是目标地址（`syscall_addr`）。  
2. **为了腾出 `RDX`** 给系统调用的第 2 个参数，必须把 `syscall_addr` 暂存 → 选用了 `R12`（非易失性寄存器）。  
3. **中间用 `RCX` 做了计数器**（因 `SSN` 已移至 `EAX`，`RCX` 空闲）。  
4. **函数结束前**，把 `R12` 中的地址移回 `RCX`（因为 `jmp` 需要一个寄存器操作数）。  
5. **恢复 `R12` 原值**，确保不破坏调用者上下文。  
6. **最后 `jmp rcx`** → 跳转到 `ntdll.dll` 中合法的 `syscall` 指令。

> **为什么要这么绕？**  
> 因为：
> - `jmp` 指令通常通过寄存器间接跳转（`jmp reg`），而不能直接从栈或内存跳转（效率/编码限制）；  
> - **`R12` 必须恢复**（它是 Callee-saved 寄存器），不能带着“脏数据”返回；  
> - 所以必须先把地址转移到一个“临时可用”的寄存器（如 `RCX`），再恢复 `R12`，最后跳转。

✅ 最终，`jmp rcx` 确实跳转到了传入的 `syscall_addr` —— 即 `ntdll.dll` 内部那条干净的 `syscall` 指令，从而实现**间接系统调用 + EDR 规避**。

#### 参数重映射（核心逻辑）

此时 Rust 传入的参数在：  
`RCX(ssn)`, `RDX(addr)`, `R8(n_args)`, `R9(arg1)`, `[RSP+0x28](arg2)`, ...

```asm
    mov eax, ecx       ; 1. 设置 SSN。将 ssn (RCX) 放入 EAX（内核约定的 SSN 寄存器）
    mov r12, rdx       ; 2. 保存跳转地址。将 syscall_addr (RDX) 暂存到 R12（防止被覆盖）
    mov rcx, r8        ; 3. 设置循环计数。将 n_args (R8) 放入 RCX，用于后面处理栈参数

    mov r10, r9        ; 4. 设置 Arg1。将 arg1 (R9) 放入 R10（内核约定的 Arg1）
    mov rdx,  [rsp + 0x28] ; 5. 设置 Arg2。从栈上取 arg2（Rust传参的第5个位置）放入 RDX
    mov r8,   [rsp + 0x30] ; 6. 设置 Arg3。从栈上取 arg3 放入 R8
    mov r9,   [rsp + 0x38] ; 7. 设置 Arg4。从栈上取 arg4 放入 R9
```

到这里，`EAX`（SSN）和前 4 个参数（`R10`, `RDX`, `R8`, `R9`）已经完全符合 `syscall` 指令的要求。

---

#### 处理栈上参数（Arg5+）

如果实际系统调用的参数超过 4 个，需要将它们搬运到正确的位置。

```asm
    sub rcx, 0x4       ; 剩余参数个数 = 总参数 - 4
    jle skip           ; 如果没有剩余参数，跳过搬运

    lea rsi,  [rsp + 0x40] ; 源地址：Rust传入的 arg5 的位置
    lea rdi,  [rsp + 0x28] ; 目标地址：内核期望 arg5 所在的位置（Shadow Space 之后）

    rep movsq          ; 循环复制 RCX 个 64位字 (QWORD)
```

这段代码做了一个精妙的**栈压缩操作**。

- **Rust 调用的栈帧**是：`[Shadow Space] [Arg2] [Arg3] [Arg4] [Arg5]...`
- **内核期望的栈帧**是：`[Shadow Space] [Arg5]...`

因为它把前 3 个“元数据参数”（`ssn`, `addr`, `n_args`）剥离了，所以需要把后面的参数（从 `Arg5` 开始）向前移动，覆盖掉之前 `Arg2` 等所在的位置。

> ⚠️ 注意：`rep movsq` 是高效的块复制指令，每次复制 8 字节（QWORD），共复制 `rcx` 次。

---

#### 执行跳转

```asm
skip:
    mov rcx, r12      ; 恢复 syscall_addr 到 RCX（准备跳转）

    ; 恢复之前保存的寄存器
    mov rsi, [rsp - 0x8]
    mov rdi, [rsp - 0x10]
    mov r12, [rsp - 0x18]

    jmp rcx           ; 跳转执行!
```

这里使用 `jmp` 而不是 `call`。这是一种**尾调用（Tail Call）**。

- `syscall_addr` 通常指向 `ntdll.dll` 中某函数（如 `NtCreateFile`）内部的 `syscall` 指令处。
- 当那里的 `syscall` 执行完毕并 `ret` 时，它会**直接返回到调用 `do_syscall` 的 Rust 代码处**（因为栈上的返回地址从未改变）。

> ✅ **规避优势**：整个过程**没有调用任何 Windows API 函数**，只是跳转到 `ntdll` 中的 `syscall` 指令，从而绕过了对 API 入口的 Hook。

---

## 3. x86 (32-bit) 汇编简述

32 位部分 (`_do_syscall`) 处理了更加复杂的兼容性问题：

- 它检查 `fs:[0xC0]`，这是 **WoW64**（Windows on Windows 64）的标志位。
- 如果在 64 位系统上运行 32 位程序，它需要通过“**天堂之门**（Heaven's Gate）”或特殊的 WoW64 转换层来执行系统调用。
- 代码手动构建栈帧并根据运行环境选择跳转到**原生执行**或 **WoW64 转换接口**。

---

## 总结

这段代码实现了一个**通用的、底层的系统调用发射器**。

- **目的**：让 Rust 代码可以直接通过 SSN 执行内核功能，而不必调用 Windows API 函数，从而绕过安全软件对 API 函数入口的监控（Hooking）。
- **亮点**：通过精细的栈操作，在**不分配新栈帧**的情况下，将 Rust 函数的参数列表动态转换为内核系统调用的参数列表。
- **适用场景**：红队工具、EDR 规避、底层系统编程、安全研究等需要直接与 Windows 内核交互的场景。

> 🔒 **注意**：此类技术仅应用于合法授权的安全研究、渗透测试或系统开发。未经授权的使用可能违反法律和道德准则。

## windows 64的软件与底层硬件的约定

Windows x64 的调用约定（Calling Convention）与winwodws内核的syscall 不同：

- **windows函数调用约定**：前 4 个参数在 `RCX`, `RDX`, `R8`, `R9`，其余在栈上。
- **Syscall 内核约定**：`syscall` 指令执行时，内核期望：
  - `EAX` = 系统服务号 (SSN)
  - `R10` = 第 1 个参数（原 `RCX` 的值，因为 `syscall` 指令会破坏 `RCX`）
  - `RDX` = 第 2 个参数
  - `R8`  = 第 3 个参数
  - `R9`  = 第 4 个参数
  - 栈    = 第 5 个及后续参数

windows的函数调用约定与内核层的syscall内核约定指令不同,内核层的 syscall 指令有特殊的硬件行为，导致这一约定必须改变.  
在此处更改的寄存器不是本项目的特例,而常见现象:  
Windows 的应用层函数调用约定（Win64 ABI）规定前四个参数是 RCX, RDX,R8,R9  

- 硬件原因（Syscall 指令的行为）,当 CPU 执行 syscall 指令时，硬件会自动执行以下操作：：
  1. 将当前的指令指针（RIP，即下一条指令的地址）保存到 `RCX` 中
  2. 将当前的标志寄存器（RFLAGS）保存到 `R11` 中
  3. 跳转到内核模式（Ring 0）

- 冲突点
如上,如果按照应用层约定，第 1 个参数存放在 RCX 中。但是 syscall指令一执行，`RCX`的值就会被硬件瞬间覆盖掉（变成了返回地址?这时候不是将RIP即下一条指令的地址保存进来了?怎么变成了返回地址? :RIP就是返回地址,在这里指向同一个东西）。如果内核进去后读取RCX，读到的不是参数，而是返回地址。

- 解决方案（Windows 内核约定）：
为了避免参数丢失，Windows 内核约定：在执行 syscall 之前，必须把第 1个参数从 RCX 移动到 R10。内核进入后，会从 R10 读取第 1 个参数，从 RDX 读取第 2个参数，依此类推?后续是否遵循从4个寄存器读取参数?还是只对R10和rdx循环读取参数?  
:后续参数依然遵循 4个寄存器的规则，并没有发生循环读取，也没有只用两个寄存器.Windows 内核系统调用（Syscall）的约定和用户层应用调用（Function Call）的约定，唯一的区别就是第 1 个参数。

即为了解决冲突,微软约定windows函数调用使用的寄存器为r10,rdx,r8,r9

**所以，任何程序（包括Chrome、Notepad、甚至是恶意软件）只要想直接发起系统调用，都必须执行 mov r10, rcx**,本例中执行的是间接的mov r10,rcx

## 被调用者还需要其他非易失性寄存器来存储被调用者的信息吗？只需要这三个吗？

在 x86-64 架构中（以 System V ABI 为例），属于被调用者保存（Callee-Saved）的寄存器一共有 6 个：`RBX`, `RBP`, `R12`, `R13`, `R14`, `R15`。

如果你的代码里只保存了前三个（比如 `RBX`, `R12`, `R13`），这隐含了一个非常重要的前提：  
`do_syscall` 这个函数的编写者（或者是编译器）承诺：在该函数的执行过程中，**绝对不会修改 `RBP`, `R14`, 和 `R15` 的值**。

那些没有被保存到栈上的寄存器（比如 `R14`），在 `do_syscall` 执行期间，它们的值仍然安稳地待在 CPU 的物理寄存器里，保持不变。

- **调用前**：`R14` 的值是 A（属于上层函数）。  
- **`do_syscall` 执行中**：因为代码逻辑没有碰 `R14`，`R14` 的值依然是 A。  
- **返回后**：上层函数继续执行，读取 `R14`，发现还是 A。

> **只要不碰它，就不需要保存它。** 这是一种性能优化，避免不必要的内存读写。

### 特殊情况区分：函数调用 vs 任务切换

有一个极易混淆的概念，取决于你当前的上下文是在做一个**普通的函数调用**，还是在做一个**任务切换（Context Switch）**：

1. **普通函数调用 / 系统调用处理函数 (Trampoline)**  
   只需要保存本函数会覆盖掉的那些寄存器。如果只用了 3 个，就只存 3 个。剩下的保持原样即可。

2. **任务切换 (Task/Thread Switching)**  
   必须全部保存。如果你是要暂停当前进程 A，去运行进程 B，那你必须把进程 A 的所有通用寄存器（包括所有的 Callee-Saved 寄存器，甚至包括栈指针 SP 和指令指针 IP）全部保存到内存里。

   - **为什么？** 因为当 CPU 转去运行进程 B 时，进程 B 可能会把 CPU 里所有的寄存器都改写一遍。如果不全部存下来，等下次切回进程 A 时，进程 A 的状态就丢了。

---

在 Microsoft x64 调用约定中：

- **易失性寄存器（可随意修改）**：`RAX`, `RCX`, `RDX`, `R8`, `R9`, `R10`, `R11`。  
- **非易失性寄存器（必须保存并恢复）**：`RBX`, `RBP`, `RDI`, `RSI`, `R12`, `R13`, `R14`, `R15`。

> **规则是**：如果你在函数里用到了“非易失性”列表里的寄存器，你就必须保存它；如果你没碰它，就不需要保存。

---

### 代码逻辑分析：为什么要碰这三个？

这段代码为了实现“间接系统调用”，需要搬运参数。正是这个搬运过程使用了 `RSI`, `RDI`, `R12`。

#### A. 为什么保存 `RSI` 和 `RDI`？

代码中有这样一段关键逻辑（用于当参数超过 4 个时，搬运栈上的参数）：

```asm
lea rsi, [rsp + 0x40]  ; 源地址 -> RSI
lea rdi, [rsp + 0x28]  ; 目的地址 -> RDI
rep movsq              ; 核心指令：复制内存
```

- **`rep movsq` 指令的副作用**：  
  这条指令会不断地把 `[RSI]` 的内容复制到 `[RDI]`，并且自动修改 `RSI` 和 `RDI` 的值（让它们指向下一个地址），直到 `RCX` 计数器归零。
- **后果**：执行完这句话，`RSI` 和 `RDI` 的值就变了（被污染了）。
- **结论**：因为 `RSI` 和 `RDI` 是非易失性的，且被 `rep movsq` 修改了，所以必须在开头保存，结尾恢复。

#### B. 为什么保存 `R12`？

代码需要腾出 `RDX` 寄存器，因为系统调用本身需要 `RDX`，但函数的输入参数 `syscall_addr`（跳转地址）也存在 `RDX` 里。

```asm
mov r12, rdx           ; 把跳转地址从 RDX 备份到 R12
...
mov rdx, [rsp + 0x28]  ; RDX 被拿去装系统调用的第 2 个参数了（覆盖了原值）
...
mov rcx, r12           ; 后面跳转时，从 R12 拿回地址
jmp rcx
```

- **资源冲突**：也就是通常说的“寄存器不够用了”。为了给系统调用参数让路，必须找个地方暂存 `syscall_addr`。
- **选择 `R12`**：作者选择了 `R12` 作为临时暂存区。
- **结论**：`R12` 属于非易失性寄存器。既然你把 `R12` 覆盖成了跳转地址，为了不破坏上层函数的环境，必须先保存它的旧值，最后再恢复。

#### C. 为什么不保存 `RBX`, `R13`, `R14`, `R15`？

因为这段汇编代码压根没有碰它们。

- 代码不需要那么多临时变量，没用到 `RBX` 等。
- 既然没修改，它们的值自然保持不变。
- 不需要保存，也就省去了 `mov` 指令的开销。

---

### 总结

这三个寄存器被选中并不是随机的，而是由指令需求决定的：

1. **`RSI`, `RDI`**：因为用了 `rep movsq` 进行内存拷贝。  
2. **`R12`**：因为需要一个安全的寄存器暂存跳转地址（`syscall_addr`）。

除此之外的其他非易失性寄存器没有被修改，所以不需要保存。

---

## `RSI`、`RDI`、`R12` 这三个寄存器能不能更改？

### 寄存器选择的底层逻辑：硬件约束 vs 程序员自由

这三个寄存器（`RSI`, `RDI`, `R12`）的选用，主要取决于 **汇编指令的硬件要求** 和 **程序员的个人偏好**。我们可以将它们清晰地分为两类来看：

---

### `RSI` 和 `RDI`：硬件指令的“硬性绑定”（Hard Constraint）

> **能不能换？几乎不能**（除非你重写整个拷贝逻辑）

#### 原因

代码中使用了 `rep movsq` 这条指令来实现参数在栈上的批量拷贝。

- 在 x86/x64 汇编中，`rep movsq` 是**硬编码的字符串操作指令**：
  - 它**必须**从 `RSI` 指向的地址读取数据（源指针）
  - 它**必须**把数据写入 `RDI` 指向的地址（目标指针）
  - CPU **不认** `RBX`、`R12` 或其他寄存器做这个操作

#### 替代方案的成本

如果你想避开 `RSI`/`RDI`，就不能用高效的 `rep movsq`，而必须手写循环：

```asm
loop_start:
    mov rax, [rbx]   ; 假设用 RBX 代替 RSI
    mov [r13], rax   ; 假设用 R13 代替 RDI
    add rbx, 8
    add r13, 8
    dec rcx
    jnz loop_start
```

这样做会带来以下问题：

- **代码体积增大**：不利于 shellcode 或隐蔽载荷  
- **性能可能下降**：`rep movsq` 在现代 CPU 上有硬件优化  
- **仍需保存寄存器**：你还是得保存 `RBX` 和 `R13`，并未减少开销

✅ **结论**：保留 `RSI` 和 `RDI` 是最优解，这是由 x86 架构的硬件设计决定的。

---

### `R12`：程序员的“任意选择”（Soft Choice）

> **能不能换？完全可以！**

#### 原因

`R12` 在这里的作用**仅仅是一个“临时仓库”**。

- 因为 `RDX`（原本存放 `syscall_addr`）要被拿去装系统调用的**第 2 个参数**
- 所以必须把 `syscall_addr` 转移到一个**非易失性寄存器**里暂存

#### 可选的替代寄存器

程序员选了 `R12`，但他完全可以从以下任一非易失性寄存器中选择，效果完全相同：

- `RBX`
- `R13`
- `R14`
- `R15`

#### 演示：将 `R12` 替换为 `RBX`

只需将所有 `R12` 替换为 `RBX`，逻辑依然成立：

```asm
do_syscall:
    mov [rsp - 0x8],  rsi
    mov [rsp - 0x10], rdi
    mov [rsp - 0x18], rbx   ; ← 以前是 R12，现在改成 RBX（保存旧值）

    mov eax, ecx
    mov rbx, rdx            ; ← 把跳转地址存入 RBX
    mov rcx, r8
    ; ...（中间逻辑不变）...
    
    mov rcx, rbx            ; ← 从 RBX 拿回跳转地址

    mov rsi, [rsp - 0x8]
    mov rdi, [rsp - 0x10]
    mov rbx, [rsp - 0x18]   ; ← 恢复 RBX 的旧值

    jmp rcx
```

✅ **结论**：`R12` 的选择是**风格或习惯问题**，无技术强制性。
