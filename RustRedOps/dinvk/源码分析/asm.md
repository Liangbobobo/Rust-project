- [关于汇编和PE文件的基础知识](#关于汇编和pe文件的基础知识)
- [win x64架构下的寄存器](#win-x64架构下的寄存器)
  - [win x64寄存器分类](#win-x64寄存器分类)
    - [通用寄存器 (General-Purpose Registers - GPRs)](#通用寄存器-general-purpose-registers---gprs)
    - [2. 指令指针寄存器 (Program Counter)](#2-指令指针寄存器-program-counter)
    - [3. 段寄存器 (Segment Registers)](#3-段寄存器-segment-registers)
    - [4. 标志寄存器 (RFLAGS)](#4-标志寄存器-rflags)
    - [5. 调试寄存器 (Debug Registers)](#5-调试寄存器-debug-registers)
    - [6. 控制寄存器 (Control Registers)](#6-控制寄存器-control-registers)
    - [7. 浮点与 SIMD 寄存器](#7-浮点与-simd-寄存器)
    - [总结：红队必备的寄存器速查表](#总结红队必备的寄存器速查表)
  - [调用约定](#调用约定)
    - [win x64与win 内核调用的约定](#win-x64与win-内核调用的约定)
    - [(回到dinvk源码)被调用者还需要其他非易失性寄存器来存储被调用者的信息吗？只需要这三个吗？](#回到dinvk源码被调用者还需要其他非易失性寄存器来存储被调用者的信息吗只需要这三个吗)
    - [](#)
    - [特殊情况区分：函数调用 vs 任务切换](#特殊情况区分函数调用-vs-任务切换)
    - [RIP](#rip)
    - [rsi](#rsi)
    - [内部布局及RSP](#内部布局及rsp)
  - [本项目中/src/syscall/asm.rs涉及的基础知识](#本项目中srcsyscallasmrs涉及的基础知识)
    - [关于间接系统调用（Indirect Syscalls）](#关于间接系统调用indirect-syscalls)
  - [代码逐行解析](#代码逐行解析)
    - [保存非易失性寄存器](#保存非易失性寄存器)
    - [mov eax, ecx mov r12, rdx mov rcx, r8](#mov-eax-ecx-mov-r12-rdx-mov-rcx-r8)
      - [为什么要执行 `mov r12, rdx`？](#为什么要执行-mov-r12-rdx)
      - [为什么要执行 `mov rcx, r8`？](#为什么要执行-mov-rcx-r8)
    - [总结](#总结)
    - [mov r10, r9 mov rdx,  \[rsp + 0x28\] mov r8,   \[rsp + 0x30\] mov r9,   \[rsp + 0x38\]](#mov-r10-r9-mov-rdx--rsp--0x28-mov-r8---rsp--0x30-mov-r9---rsp--0x38)
    - [这么倒腾寄存器的目的](#这么倒腾寄存器的目的)
      - [1. 技术层面：消除“包装函数”引入的偏差（“搬运工”）](#1-技术层面消除包装函数引入的偏差搬运工)
      - [2. 战术层面：实现“间接系统调用”（“隐身术”）](#2-战术层面实现间接系统调用隐身术)
    - [lea rsi, \[rsp + 0x40\] lea rdi, \[rsp + 0x28\]](#lea-rsi-rsp--0x40-lea-rdi-rsp--0x28)
    - [jmp rcx](#jmp-rcx)
      - [寄存器值追踪：`jmp rcx` 到底跳转到哪里？](#寄存器值追踪jmp-rcx-到底跳转到哪里)
        - [1. 代码开头：保存现场](#1-代码开头保存现场)
        - [2. 参数“乾坤大挪移”（关键步骤）](#2-参数乾坤大挪移关键步骤)
        - [3. 处理参数搬运（如果参数 \> 4）](#3-处理参数搬运如果参数--4)
        - [4. 恢复与准备跳转](#4-恢复与准备跳转)
        - [总结：为什么绕这么一大圈？](#总结为什么绕这么一大圈)
      - [参数重映射（核心逻辑）](#参数重映射核心逻辑)
      - [处理栈上参数（Arg5+）](#处理栈上参数arg5)
      - [执行跳转](#执行跳转)
  - [3. x86 (32-bit) 汇编简述](#3-x86-32-bit-汇编简述)
  - [总结](#总结-1)
    - [代码逻辑分析：为什么要碰这三个？](#代码逻辑分析为什么要碰这三个)
      - [A. 为什么保存 `RSI` 和 `RDI`？](#a-为什么保存-rsi-和-rdi)
      - [B. 为什么保存 `R12`？](#b-为什么保存-r12)
      - [C. 为什么不保存 `RBX`, `R13`, `R14`, `R15`？](#c-为什么不保存-rbx-r13-r14-r15)
    - [总结](#总结-2)
  - [`RSI`、`RDI`、`R12` 这三个寄存器能不能更改？](#rsirdir12-这三个寄存器能不能更改)
    - [寄存器选择的底层逻辑：硬件约束 vs 程序员自由](#寄存器选择的底层逻辑硬件约束-vs-程序员自由)
    - [`RSI` 和 `RDI`：硬件指令的“硬性绑定”（Hard Constraint）](#rsi-和-rdi硬件指令的硬性绑定hard-constraint)
      - [原因](#原因)
      - [替代方案的成本](#替代方案的成本)
    - [`R12`：程序员的“任意选择”（Soft Choice）](#r12程序员的任意选择soft-choice)
      - [原因](#原因-1)
      - [可选的替代寄存器](#可选的替代寄存器)
      - [演示：将 `R12` 替换为 `RBX`](#演示将-r12-替换为-rbx)
    - [](#-1)

# 关于汇编和PE文件的基础知识


# win x64架构下的寄存器

## win x64寄存器分类

x64 拥有 16 个 64 位通用寄存器.在 Windows 调用约定（Microsoft x64 ABI）中，它们的角色非常固定。其中有些寄存器有不同的特性





### 通用寄存器 (General-Purpose Registers - GPRs)

x64 拥有 16 个 64 位通用寄存器。在 Windows 调用约定（Microsoft x64 ABI）中，它们的角色非常固定。  
- **易失性寄存器（可随意修改）**：`RAX`, `RCX`, `RDX`, `R8`, `R9`, `R10`, `R11`。  
- **非易失性寄存器（必须保存并恢复）**：`RBX`, `RBP`, `RDI`, `RSI`, `R12`, `R13`, `R14`, `R15`。

> **规则是**：如果你在函数里用到了“非易失性”列表里的寄存器，你就必须保存它；如果你没碰它，就不需要保存。





| 寄存器 | 别名/子集        | 易失性 (Volatile) | Windows 调用约定中的用途 & 红队视角                                                                 |
|--------|------------------|-------------------|------------------------------------------------------------------------------------------------------|
| RAX    | EAX, AX, AL      | 易失性            | 返回值。在系统调用中存放 SSN (System Service Number)。Shellcode 常通过它获取函数执行结果。              |
| RCX    | ECX, CX, CL      | 易失性            | 第 1 个参数。在 syscall 指令执行时，会被内核覆盖用于存储返回地址。                                      |
| RDX    | EDX, DX, DL      | 易失性            | 第 2 个参数。在某些乘除法指令中作为辅助寄存器。                                                         |
| RBX    | EBX, BX, BL      | 非易失性          | 基地址寄存器。因为它是非易失性的，常被红队用于在复杂逻辑中暂存关键数据的基指针。                        |
| RSP    | ESP, SP          | 特殊              | 栈指针。指向当前栈顶。红队注意：Windows 要求进入 API 前栈必须 16 字节对齐。                             |
| RBP    | EBP, BP          | 非易失性          | 栈基址指针。虽然现代编译器常用它做通用寄存器，但在进行栈回溯（Stack Walking）或混淆时仍具有结构化意义。 |
| RSI    | ESI, SI          | 非易失性          | 源变址寄存器。常用于内存拷贝（rep movs）。在注入代码中常用来指向原始 Payload 地址。                     |
| RDI    | EDI, DI          | 非易失性          | 目的变址寄存器。常用于内存拷贝的目标地址。                                                              |
| R8     | R8D, R8W, R8B    | 易失性            | 第 3 个参数。                                                                                           |
| R9     | R9D, R9W, R9B    | 易失性            | 第 4 个参数。                                                                                           |
| R10    | R10D...          | 易失性            | 内核调用第 1 个参数。由于 syscall 会占用 RCX，Windows 要求在发起 syscall 前将 RCX 的值移动到 R10。      |
| R11    | R11D...          | 易失性            | 临时寄存器。执行 syscall 后，RFLAGS 会被保存到这里。                                                    |
| R12 - R15 | R12D...       | 非易失性          | 通用寄存器。常被红队用于存放不需要频繁从内存中读取的静态配置或加密密钥。                                |

---

### 2. 指令指针寄存器 (Program Counter)

* **RIP**: 始终指向下一条将要执行的指令地址。
    * **红队视角 (PIC)**: x64 支持 RIP-relative addressing（RIP 相对寻址）。编写位置无关代码 (Position Independent Code) 时，可以通过 `lea rax, [rip + label]` 轻松获取数据地址，无需像 x86 那样使用 call/pop 技巧。

---

### 3. 段寄存器 (Segment Registers)

在 64 位模式下，大多数段寄存器（CS, DS, ES, SS）已失去意义，但 GS 寄存器至关重要。

* **GS**: 在 Windows x64 中，GS 寄存器指向内核定义的线程环境块 (TEB)。
    * `GS:[0x30]`: 指向 TEB 地址。
    * `GS:[0x60]`: 指向 PEB (Process Environment Block)。
    * **红队视角**: 这是在不调用任何 API（如 GetModuleHandle）的情况下定位 ntdll.dll 和 kernel32.dll 的唯一途径。通过遍历 PEB → Ldr → InLoadOrderModuleList，可以手动寻找 API 地址。

---

### 4. 标志寄存器 (RFLAGS)

64 位的状态寄存器，每一位代表不同的处理器状态。

* **ZF (Zero Flag)**: 比较结果为零时置位。常用于条件跳转。
* **TF (Trap Flag)**: 陷阱标志。
    * **红队视角**: 如果设置了此位，CPU 每执行一条指令就会产生一个 INT 1 异常。常用于反调试（检测是否有调试器正在单步跟踪）。
* **DF (Direction Flag)**: 方向标志。控制字符串操作指令（如 movsd）是递增还是递减。

---

### 5. 调试寄存器 (Debug Registers)

这些寄存器是硬件级别的，对红队进行 EDR 回避非常有用。

* **DR0 - DR3**: 存储硬件断点的线性地址（可以监视 4 个位置）。
* **DR6**: 状态寄存器，显示是哪个断点触发了异常。
* **DR7**: 控制寄存器，定义断点的触发条件（执行、写入、读写）和长度。
    * **红队视角**: 可以通过设置硬件断点来 Hook 敏感函数（如 NtWriteVirtualMemory），而无需修改目标函数的内存（无需 0xE9 JMP），从而规避 EDR 的内存扫描。

---

### 6. 控制寄存器 (Control Registers)

这些通常在内核开发或驱动层利用时涉及。

* **CR0**: 控制 CPU 工作模式（保护模式、分页等）。其中 WP (Write Protect) 位控制只读内存是否允许写入。
* **CR2**: 存储发生页面错误（Page Fault）时的虚拟地址。
* **CR3**: 页表基址寄存器。指向当前进程的顶级页表（PML4）。
    * **红队视角**: 在内核渗透中，切换 CR3 可以实现跨进程读取内存。
* **CR4**: 控制扩展功能（如 SMEP, SMAP 防护）。

---

### 7. 浮点与 SIMD 寄存器

* **XMM0 - XMM15**: 128 位寄存器，用于浮点运算。
* **YMM0 - YMM15**: 256 位寄存器（AVX）。
    * **红队视角**: 在编写高度混淆的加密算法（如自定义的 AES 变体）时，使用这些寄存器可以提高效率，并使反汇编结果对静态分析极不友好。

---

### 总结：红队必备的寄存器速查表

1. 想找 PEB? 看 `gs:[60h]`。
2. 想发 Syscall? RAX 放编号，R10 放参数 1。
3. 函数返回了？ 检查 RAX 是否为 0 (Success)。
4. 栈崩了？ 检查 RSP 是否在调用前完成了 `sub rsp, 28h` (Shadow Space) 且 16 字节对齐。
5. 反调试？ 检查 RFLAGS 的 TF 位或 DR0-DR7 的值。


## 调用约定 

### win x64与win 内核调用的约定

1. Shadow Space (预留空间): 即使函数没有参数，调用者也必须在栈上分配32 字节 (0x20) 的空间。这是给被调用者保存 RCX, RDX, R8, R9 用的。
2. 栈对齐: 调用 call 指令前，RSP 必须以 16 字节对齐（加上 call压入的返回地址后，进入函数内部时 RSP 通常是以 0x...8 结尾）。
3. Syscall 变化:
* 用户态调用 API: RCX, RDX, R8, R9
* 执行 syscall 指令时: EAX=SSN, R10, RDX, R8, R9

Windows x64应用层函数调用约定（Win64 ABI）与winwodws内核的syscall 不同：  

**windows的函数调用约定与内核层的syscall内核约定指令不同,内核层的 syscall 指令有特殊的硬件行为，导致这一约定必须改变:**  
- 硬件原因（Syscall 指令的行为）,当 CPU 执行 syscall 指令时，硬件会自动执行以下操作：：
1. 将当前的指令指针（RIP，即下一条指令的地址）保存到 `RCX` 中
2. 将当前的标志寄存器（RFLAGS）保存到 `R11` 中
3. 跳转到内核模式（Ring 0）

- 冲突点  
如上,如果按照应用层约定，第 1 个参数存放在 RCX 中。但是 syscall指令一执行，`RCX`的值就会被硬件瞬间覆盖掉（变成了返回地址?这时候不是将RIP即下一条指令的地址保存进来了?怎么变成了返回地址? :RIP就是返回地址,在这里指向同一个东西）。如果内核进去后读取RCX，读到的不是参数，而是返回地址。

- 解决方案（Windows 内核约定）：
为了避免参数丢失，Windows 内核约定：在执行 syscall 之前，必须把第 1个参数从 RCX 移动到 R10。内核进入后，会从 R10 读取第 1 个参数，从 RDX 读取第 2个参数，依此类推?后续是否遵循从4个寄存器读取参数?还是只对R10和rdx循环读取参数?  
:后续参数依然遵循 4个寄存器的规则，并没有发生循环读取，也没有只用两个寄存器.Windows 内核系统调用（Syscall）的约定和用户层应用调用（Function Call）的约定，唯一的区别就是第 1 个参数。

即为了解决冲突,微软约定windows函数调用使用的寄存器为r10,rdx,r8,r9

**所以，任何程序（包括Chrome、Notepad、甚至是恶意软件）只要想直接发起系统调用，都必须执行 mov r10, rcx**,本例中执行的是间接的mov r10,rcx

- **windows函数调用约定**：前 4 个参数在 `RCX`, `RDX`, `R8`, `R9`，其余在栈上。
- **Syscall 内核约定**：`syscall` 指令执行时，内核期望：
  - `EAX` = 系统服务号 (SSN)
  - `R10` = 第 1 个参数（原 `RCX` 的值，因为 `syscall` 指令会破坏 `RCX`）
  - `RDX` = 第 2 个参数
  - `R8`  = 第 3 个参数
  - `R9`  = 第 4 个参数
  - 栈    = 第 5 个及后续参数

**即cpu执行syscall时硬件会征用rcx r11**


### (回到dinvk源码)被调用者还需要其他非易失性寄存器来存储被调用者的信息吗？只需要这三个吗？

在 x86-64 架构中（以 System V ABI 为例），属于被调用者保存（Callee-Saved）的寄存器一共有 6 个：`RBX`, `RBP`, `R12`, `R13`, `R14`, `R15`。

如果你的代码里只保存了前三个（比如 `RBX`, `R12`, `R13`），这隐含了一个非常重要的前提：  
`do_syscall` 这个函数的编写者（或者是编译器）承诺：在该函数的执行过程中，**绝对不会修改 `RBP`, `R14`, 和 `R15` 的值**。

那些没有被保存到栈上的寄存器（比如 `R14`），在 `do_syscall` 执行期间，它们的值仍然安稳地待在 CPU 的物理寄存器里，保持不变。

- **调用前**：`R14` 的值是 A（属于上层函数）。  
- **`do_syscall` 执行中**：因为代码逻辑没有碰 `R14`，`R14` 的值依然是 A。  
- **返回后**：上层函数继续执行，读取 `R14`，发现还是 A。

> **只要不碰它，就不需要保存它。** 这是一种性能优化，避免不必要的内存读写。

### 

### 特殊情况区分：函数调用 vs 任务切换

有一个极易混淆的概念，取决于你当前的上下文是在做一个**普通的函数调用**，还是在做一个**任务切换（Context Switch）**：

1. **普通函数调用 / 系统调用处理函数 (Trampoline)**  
只需要保存本函数会覆盖掉的那些寄存器。如果只用了 3 个，就只存 3 个。剩下的保持原样即可。

2. **任务切换 (Task/Thread Switching)**  
必须全部保存。如果你是要暂停当前进程 A，去运行进程 B，那你必须把进程 A 的所有通用寄存器（包括所有的 Callee-Saved 寄存器，甚至包括栈指针 SP 和指令指针 IP）全部保存到内存里。

- **为什么？** 因为当 CPU 转去运行进程 B 时，进程 B 可能会把 CPU 里所有的寄存器都改写一遍。如果不全部存下来，等下次切回进程 A 时，进程 A 的状态就丢了。


### RIP

专用寄存器,有专门的用途,不能更改

RIP (Instruction Pointer) 是x86-64架构中的程序计数器（Program Counter）寄存器，它的作用是存储下一条要执行的指令的地址.

作用:

1. 跟踪执行流程：RIP始终指向CPU将要执行的下一条指令的地址
2. 控制程序流程：通过修改RIP的值，可以改变程序的执行路径（如跳转、调用、返回等）

在windwos系统调用(syscall)中

1. 当执行syscall指令时，CPU会自动将当前RIP值（即下一条指令地址）保存到RCX寄存器
2. 在x86-64架构中，RIP寄存器不能被直接读取或写入(避免程序直接修改执行流程;保持指令执行的正确性和安全性).但可以通过jmp 指令：直接修改RIP（无条件跳转）;call 指令：将返回地址（RIP+指令长度）压入栈，然后修改RIP;ret 指令：从栈中弹出地址并加载到RIP来间接操作RIP


### rsi

### 内部布局及RSP

这不仅是一个关于内存布局的问题，更是一个关于 红队/黑客汇编代码优化（Hacker Assembly Optimization） 的技巧问题。

这里有两个反直觉的核心点，我将为你一一揭秘：

栈的生长方向：栈绝对是向下（向低地址）生长的。

负偏移的秘密 (rsp - 0x8)：为什么不先 sub rsp 甚至不 push，却直接往 rsp 下面写数据？

我们用图解来彻底打破这个疑惑。

一、 核心物理定律：栈是向下生长的

首先，请把这个画面印在脑子里：内存地址像一栋大楼。

高地址 (High) 是顶层。

低地址 (Low) 是底层。

当你入栈 (Push) 或者 分配栈空间 时，你是往下走（地址变小）。
当你读取旧数据（如调用者传来的参数）时，你是抬头往上看（地址变大）。

二、 内存分布图解 (基于该段代码)

在这段 do_syscall 代码运行的瞬间，内存是这样分布的：

``` text
内存地址 (虚拟)           内容描述
+=======================+ -----------------------
| RSP + 0x28 (40)       |  Arg 5 (外部传来的)     ↑
| RSP + 0x20 (32)       |  Shadow Space          ｜
| RSP + 0x18 (24)       |  Shadow Space          ｜ (往上看)
| RSP + 0x10 (16)       |  Shadow Space          ｜ (正偏移)
| RSP + 0x08 (8)        |  Shadow Space          ｜
| RSP + 0x00 (0)        |  Return Address (返回地址)
+=======================+ <----【当前真实的 RSP】-----
| RSP - 0x08 (-8)       |  保存的 RSI             ｜
+-----------------------+                        ｜ (往下看)
| RSP - 0x10 (-16)      |  保存的 RDI             ｜ (负偏移)
+-----------------------+                        ｜
| RSP - 0x18 (-24)      |  保存的 R12             ↓
+-----------------------+ 
低地址 (Low Address)
```

解析你的疑惑：

地址数值越大，位置越靠上。

栈向低地址延伸（图中的下方）。

RSP 站在 0x00 的位置。

jmp rcx 之前的恢复逻辑

你在开头（函数最上面）做了 mov [rsp - 0x8], rsi。意思是：“不用移动 RSP 指针，直接弯腰把 RSI 的值放在脚下的地板缝里。”

所以在结尾 skip 处，自然要弯腰把它捡回来：mov rsi, [rsp - 0x8]。

三、 为什么要用负偏移 (rsp - 0x8)？

正常程序的汇编（编译器生成的）通常是这样的：

``` text
push rsi      ; rsp 自动减 8
push rdi      ; rsp 又自动减 8
```

mov rdx, [rsp + 0x38] ; 因为 rsp 变了，所以读取上层参数的偏移量也要跟着变！麻烦！

红队/Shellcode 优化写法（你的代码）：
作者使用了 “利用 Red Zone（类比）” 的技巧。

原理：
作者不想移动 RSP 指针。

好处：如果 RSP 保持不变，那么所有读取外部参数的偏移量（如 0x28）都是固定的常量。程序员不需要因为保存了几个寄存器，就痛苦地去重新计算偏移量（是加0x8还是0x10？）。

操作：

mov [rsp - 0x8], rsi：并没有执行 sub rsp, 8。

意思是：我占用了栈顶下方的内存，但我没有告诉 CPU 的栈管理器。我在“偷偷”使用未分配的空间。

**风险提示（这也是该项目被称为 Hacker Code 的原因）：**  
在标准的 Windows x64 ABI 中，RSP 下方的内存（负偏移）理论上是 Volatile (易变的)。如果此时发生了中断或异常，操作系统可能会在 RSP 下方保存上下文，从而覆盖掉你存的 rsi/rdi。
但在Syscall 存根这种极短、原子性极强的代码片段中，作者赌它不会发生中断，从而换取了代码的简洁和无需计算 RSP 偏移的便利。

总结:  
1. 栈向低地址增长：所以开辟空间通常用减法。
2. RSP - 0x8 (负偏移)：这是在向更低的地址（栈顶下方）存数据。
3. 作者的意图：偷懒/固定偏移。他不移动 RSP 指针，是为了让上方 [rsp + 0x28] 读取参数的代码永远不用修改偏移量。这是手写汇编的一种常见 Trick。

**RSP到底会不会自动指向栈顶?**

这是一个直击CPU 硬件机制和指令行为的核心问题。你一定要把“逻辑上的栈顶”和“物理上的寄存器行为”区分开。

1. RSP 不会自动变，除非你修改它

RSP 本质上只是一个 普通的寄存器，里面存了一个 64 位的整数（地址）。  

会自动修改 RSP 的指令：  
PUSH: 只有这一类指令，CPU 会自动执行 RSP = RSP - 8。  
POP: 自动执行 RSP = RSP + 8。  
CALL / RET: 自动压入/弹出返回地址并修改 RSP。

不会修改 RSP 的指令：  
MOV: 这只是搬运数据。

代码里的 mov [rsp - 0x8], rsi 翻译给 CPU 听就是：“请保持 RSP 的值完全不动，用算术计算一下 RSP - 8 这个位置的内存地址，然后把 RSI 的值写进去。”

所以：RSP 在这两行汇编里没有变小，因为它没遇到 sub 或 push 指令。它只是像一个锚点，被用来定位附近的内存。

2. 为什么写到 RSP “下面”是可以的？（脏操作）

在操作系统原理中，RSP 以下的空间通常被称为 "易变区域" 或 "红区 (Red Zone)"（在 Linux ABI 中有明确定义，Windows 没有）。

Windows 的官方规则：RSP 以下的内存是“不安全”的。如果有硬件中断（Interrupt）发生，或者异常处理（Exception）介入，操作系统会把保存现场的数据压入 RSP 下方，覆盖掉 你刚刚写的 rsi。

**为什么敢这么做？**

这是一个赌博（Hack Trick）：这是一段极其短小的、位于用户态的叶子函数 (Leaf Function)（函数内部没有再 Call 其他函数）。

作者打赌在这几十个 CPU 周期内，不会发生会导致堆栈被破坏的内核中断事件。

在 Shellcode 和红队开发中，为了极致的体积优化和方便计算偏移，经常违规操作。

1. 作者的真实意图：为了“固定坐标系”

这是这段代码不移动 RSP 的最大原因——为了偷懒。

假设进入函数时，参数 5 在 [RSP + 0x28]。

如果不偷懒（标准写法）：

```asm
push rsi      ; RSP 变了！ RSP = 原RSP - 8
push rdi      ; RSP 变了！ RSP = 原RSP - 16
push r12      ; RSP 变了！ RSP = 原RSP - 24

; 现在你想读参数 5
; 你不能用 [rsp + 0x28] 了，因为坐标系（RSP）变了！
; 你必须自己心算：0x28 + 24 = 0x40
mov rdx, [rsp + 0x40] ; 极其容易算错，代码难维护


红队优化（偷懒写法）：

; 我不碰 RSP，我把它当定海神针
mov [rsp - 8], rsi
mov [rsp - 16], rdi
mov [rsp - 24], r12

; 既然 RSP 没变，那参数的坐标也不变
mov rdx, [rsp + 0x28] ; 还是 0x28！舒服！直接照抄偏移量
总结
```

物理上：MOV [RSP-8], ... 指令只写内存，不改寄存器。RSP 数值没变。

逻辑上：作者在“偷用”栈顶以下的非法空间。

动机上：为了锁死坐标系。保持 RSP 不动，就能保证后面读取外部参数（rsp+0x28）的偏移量永远是固定的，不需要根据保存了几个寄存器来动态计算修正值。这是一个高超的编写技巧。



## 本项目中/src/syscall/asm.rs涉及的基础知识

### 关于间接系统调用（Indirect Syscalls）

在红队操作（RedOps）和 EDR 规避技术中，直接调用 Windows API（如 CreateFile）或甚至是底层的 NtCreateFile 都可能被安全软件（EDR/AV）在用户模式下挂钩（Hook）并监控。为了绕过这些监控，该代码实现了手动设置 CPU 寄存器并跳转到 ntdll.dll 中的 syscall 指令地址执行，从而避开函数入口处的 Hook。

```rust
extern "C" {
    pub fn do_syscall(
        ssn: u16,          // 参数 1 (rcx): 系统服务号 (System Service Number)
        syscall_addr: u64, // 参数 2 (rdx): syscall 指令的内存地址
        n_args: u32,       // 参数 3 (r8) : 实际系统调用的参数个数
        ...                // 参数 4+ (r9, stack): 实际传递给系统调用的参数 (arg1, arg2...)
    ) -> i32;
}
```

这个函数的签名非常特殊。它是一个“垫片”函数，负责接收参数，重新排列它们以符合 Windows 系统调用的内核约定，然后跳转执行。

do_syscall这个函数本身需要接收 3 个额外的控制参数，而这 3个参数霸占了本该属于系统调用参数的前三个寄存器位置。因此,需要将rdx r8 r9位移接收这三个参数.且ecx因为windows的调用约定,也需要改变.


## 代码逐行解析

### 保存非易失性寄存器

```asm
do_syscall:
    mov [rsp - 0x8],  rsi
    mov [rsp - 0x10], rdi
    mov [rsp - 0x18], r12
```

这里非常规地将 `rsi`, `rdi`, `r12`（这些是“被调用者保存”的寄存器）保存到了栈顶下方（Shadow Space 区域或者更低）。这是为了在函数结束前恢复它们，保证不破坏调用者的环境。

> ✅ **关键点**：虽然 `rsi`/`rdi` 在 Windows x64 中不是标准 callee-saved 寄存器，但某些上下文（如 Rust 编译器生成的代码）可能依赖其值不变，因此保守保存。

[代码逻辑分析：为什么要碰这三个？](#代码逻辑分析为什么要碰这三个)

### mov eax, ecx mov r12, rdx mov rcx, r8

你的 Rust 函数签名：

```rust
pub fn do_syscall(ssn: u16, syscall_addr: u64, n_args: u32, ...)
```

根据 **Windows x64 ABI**，它只决定了**参数刚进入函数时的初始位置**：

```rust
pub fn do_syscall(
    ssn: u16,           // 参数 1 (RCX)
    syscall_addr: u64,  // 参数 2 (RDX)
    n_args: u32,        // 参数 3 (R8)
    arg1: u64,          // 参数 4 (R9)
    arg2: u64,          // 参数 5 (栈: RSP+0x28)
    arg3: u64,          // 参数 6 (栈: RSP+0x30)
    ...
)
```

Windows 系统调用底层（`syscall` 指令）要求的寄存器布局是：

| 目标用途 | 所需寄存器 | 值来源 |
|----------|------------|--------|
| 系统服务号（SSN） | `RAX` | 来自 `RCX` |
| 参数1 | `R10` | 来自 `R9` |
| 参数2 | `RDX` | 来自栈上 `[rsp + 0x28]` |
| 参数3 | `R8` | 来自栈上 `[rsp + 0x30]` |
| 参数4 | `R9` | 来自栈上 `[rsp + 0x38]` |

#### 为什么要执行 `mov r12, rdx`？

**原因：保护 `syscall_addr`（系统调用地址），因为 `RDX` 即将被覆盖。**

们把 do_syscall 想象成一个中转站，它需要处理两套不同的参数规则：
1. 第一套规则：进入 do_syscall 时 (Rust -> 汇编)
按照 Windows x64 调用约定，Rust 调用 do_syscall 时，寄存器里装的是：  
* `rcx`: 第 1 个参数 (SSN 系统调用号)
* `rdx`: 第 2 个参数 (`syscall_addr`，即 ntdll 中那行指令的地址)
* `r8` : 第 3 个参数 (参数个数)
* r9` : 第 4 个参数 (目标 WinAPI 的第 1 个参数)

此时，`rdx` 里的值是我们要跳转的目标地址 

2. 第二套规则：执行 syscall 指令前 (准备进入内核)

当我们要真正执行 jmp syscall_addr 进入内核时，内核要求寄存器必须变成：  

* `eax`: SSN (系统调用号)
* `r10`: 目标 WinAPI 的第 1 个参数
* `rdx`: 目标 WinAPI 的第 2 个参数
* `r8` : 目标 WinAPI 的第 3 个参数
* `r9` : 目标 WinAPI 的第 4 个参数

此时，`rdx` 必须腾出来，装载目标 WinAPI 真正的第 2 个参数

Windows x64 调用约定（Calling Convention）与内核系统调用（Syscall ABI）之间最核心的设计差异

1. eax/rax 不算内核系统调用的定义一个参数
2. 在 Windows x64 的 用户态（User Mode） 调用约定中，前四个参数永远是通过rcx, rdx, r8, r9 传递的。eax 在用户态函数调用里通常只用来存放 返回值
3. 在执行 `syscall`（内核态切换） 时，规则变了:`eax` (或 `rax`)：它不是用来传参数的，它是“功能选择器”。你告诉内核：“我要调用 0x18 号功能（比如NtAllocateVirtualMemory）”
* `r10`, `rdx`, `r8`, `r9` ...：这些才是真正的 “函数参数”


关键点： do_syscall 这个汇编函数的作用，就是把 Rust传进来的“普通参数”，翻译成内核能懂的“系统调用指令”。
* Rust 传给 do_syscall 的第一个参数是 ssn（系统调用号），它在 rcx 里。
* 汇编第一步 mov eax, ecx 就是把这个“功能号”从参数寄存器移到“功能选择器”eax 中。

#### 为什么要执行 `mov rcx, r8`？

**原因：腾出 `R8` 寄存器，并为 `rep movsq` 设置计数器。**

1. **冲突**：  
   进入函数时，`R8` 寄存器里存放的是 `do_syscall` 的第 3 个参数，即 `n_args`（参数个数）。  
   但**实际的系统调用需要使用 `R8` 来存放它的第 3 个参数**。

2. **准备计数器**：  
   代码后面有一段逻辑 `rep movsq`，用于当参数超过 4 个时，搬运栈上的剩余参数。  
   汇编指令 `rep`（repeat）依赖 **`RCX` 寄存器作为计数器（Counter）**。

3. **复用 `RCX`**：  
   刚进入函数时 `RCX` 存的是 `SSN`，但 `SSN` 已经被移到了 `EAX`（`mov eax, ecx`），所以 `RCX` 现在是空闲的。  
   将 `n_args` 从 `R8` 移到 `RCX`，既：
   - 腾出了 `R8` 给系统调用参数使用，
   - 又正好为后面的参数搬运循环设置好了计数器。

---

### 总结

这几行代码是在做一个“乾坤大挪移”，将 Rust 函数传进来的元数据（`SSN`、地址、数量）挪走，以便把寄存器（`RDX`、`R8`）腾出来给真正的系统调用参数使用。

### mov r10, r9 mov rdx,  [rsp + 0x28] mov r8,   [rsp + 0x30] mov r9,   [rsp + 0x38]

### 这么倒腾寄存器的目的

#### 1. 技术层面：消除“包装函数”引入的偏差（“搬运工”）

你的 Rust 函数 `do_syscall` 是一个包装器（Wrapper）。为了告诉这个包装器要做什么，你传给它 3 个元数据参数：

1. **SSN**（系统调用号，如 `0x18` for `NtAllocateVirtualMemory`）  
2. **Address**（你要跳转到的 `syscall` 指令的内存地址）  
3. **Count**（参数个数）

这导致了**参数位置的错位**：

- 真正的第 1 个参数（比如 `ProcessHandle`），本该在 `R10`，结果被挤到了 `R9`（因为前三个位置被元数据占了）。  
- 真正的第 2 个参数，本该在 `RDX`，结果被挤到了栈上。

汇编代码的目的就是把这些被“挤偏”了的参数，通过手动搬运，**复位到内核要求的标准位置上**。

| 逻辑参数        | 在 Wrapper 中的位置 (现状) | 内核要求的位置 (目标) | 汇编做的操作                        |
|-----------------|----------------------------|------------------------|-------------------------------------|
| 元数据：SSN     | `RCX`                      | `EAX`                  | `mov eax, ecx`（设置系统调用号）    |
| 元数据：Address | `RDX`                      | （用于跳转）           | `mov r12, rdx` … `jmp rcx`（准备跳转） |
| 元数据：Count   | `R8`                       | （用于循环）           | `mov rcx, r8`（用作 `rep movsq` 计数器） |
| 真实参数 1      | `R9`                       | `R10`                  | `mov r10, r9`（归位）               |
| 真实参数 2      | 栈 (`RSP+0x28`)            | `RDX`                  | `mov rdx, [rsp+0x28]`（归位）       |
| 真实参数 3      | 栈 (`RSP+0x30`)            | `R8`                   | `mov r8, [rsp+0x30]`（归位）        |
| 真实参数 4      | 栈 (`RSP+0x38`)            | `R9`                   | `mov r9, [rsp+0x38]`（归位）        |

> **一句话总结**：代码在执行“乾坤大挪移”，把 Rust 函数调用约定的布局，强行转换成 Windows 内核系统调用约定的布局。

---

#### 2. 战术层面：实现“间接系统调用”（“隐身术”）

如果只是为了调用内核函数，直接使用 Windows API（如 `OpenProcess`）或者直接写 `syscall` 指令也可以。为什么要搞这么复杂？

这里的**关键在于最后那句 `jmp rcx`**（其实是跳转到 `syscall_addr`）。

- **常规调用**：  
  程序调用 `kernel32.dll` → `ntdll.dll` → `syscall`。  
  EDR（端点检测响应系统）通常会在 `ntdll.dll` 的函数入口处挂钩（Hook），监控你的行为。

- **直接系统调用 (Direct Syscall)**：  
  你自己写汇编执行 `syscall` 指令。  
  EDR 可能会检测到 `syscall` 指令并非来自 `ntdll.dll` 的内存区域，从而报警（**RIP Sanity Check**）。

- **间接系统调用 (Indirect Syscall) —— 这段代码的目的**：
  1. 你先在 `ntdll.dll` 中找到一条**合法的 `syscall` 指令的地址**（这就是传入的 `syscall_addr`）。
  2. 你把参数全部准备好（就是上面做的寄存器转移）。
  3. 你**跳转（Jump）到 `ntdll.dll` 里的那个 `syscall` 指令去执行**。

> **最终目的**：  
> 当 `syscall` 指令执行进入内核时，内核检查调用栈，发现上一条指令确实是在合法的 `ntdll.dll` 里面执行的，于是**骗过了安全检查**，认为这是一个合法的系统调用，从而实现了红队操作中的**免杀 / Evasion**。

### lea rsi, [rsp + 0x40] lea rdi, [rsp + 0x28]

```rust
; 将调用者传入的多余参数平移到当前栈帧的参数区
lea rsi, [rsp + 0x40]    ; RSI = 源地址 (当前函数的第 8 个参数位置,前四个在shadow中)
lea rdi, [rsp + 0x28]    ; RDI = 目标地址 (符合 ABI要求的栈参数起始点)
rep movsq                ; 批量拷贝 8 字节块
```

**为什么从第 8 个参数 ([rsp + 0x40]) 开始平移？**

do_syscall签名:
```rust
#[doc(hidden)]
#[allow(unused_doc_comments)]
#[cfg(target_arch = "x86_64")]
unsafe extern "C" {
pub fn do_syscall(
ssn: u16,           // 第 1 个参数 (rcx)
syscall_addr: u64,  // 第 2 个参数 (rdx)
n_args: u32,        // 第 3 个参数 (r8)
arg1: usize,        // 第 4 个参数 (r9) -> 对应 WinAPI 的第 1 参
arg2: usize,        // 第 5 个参数 (栈 [rsp + 0x28]) -> 对应 WinAP的第 2 参
arg3: usize,        // 第 6 个参数 (栈 [rsp + 0x30]) -> 对应 WinAP的第 3 参
arg4: usize,        // 第 7 个参数 (栈 [rsp + 0x38]) -> 对应 WinAP的第 4 参
arg5: usize,        // 第 8 个参数 (栈 [rsp + 0x40]) -> 对应 WinAP的第 5 参
...
)
}
```
由于do_syscall函数多出了3个参数,因此在调用系统函数时,在传第5个参数时,应该对应do_syscall函数的第8个参数(5+3)


### jmp rcx

#### 寄存器值追踪：`jmp rcx` 到底跳转到哪里？

这是一个容易让人眼花缭乱的地方，让我们回过头仔细追踪一下寄存器的值。

在 `do_syscall` 函数中，`jmp rcx` 实际上跳转到的是 **`syscall_addr`**（即系统调用指令在 `ntdll.dll` 中的内存地址）。

---

##### 1. 代码开头：保存现场

```asm
do_syscall:
    mov [rsp - 0x8],  rsi
    mov [rsp - 0x10], rdi
    mov [rsp - 0x18], r12  ; ← R12 被保存到栈上
```

- 此时 `RSI`、`RDI`、`R12` 的原始值被压入栈中，以遵守调用约定（Callee-saved）。

---

##### 2. 参数“乾坤大挪移”（关键步骤）

进入函数时的初始状态：

- `RCX` = `SSN`（参数1）  
- `RDX` = `syscall_addr`（参数2，**目标跳转地址！**）  
- `R8` = `n_args`（参数3）

执行以下操作：

```asm
    mov eax, ecx   ; EAX = SSN（供 syscall 使用）
    mov r12, rdx   ; R12 = syscall_addr ← 关键：目标地址被备份到 R12
    mov rcx, r8    ; RCX = n_args ← 用于后续 rep movsq 的计数器
```

✅ **此时状态**：
- `R12` 持有 `syscall_addr`
- `RCX` 持有 `n_args`（不再包含 SSN）

---

##### 3. 处理参数搬运（如果参数 > 4）

```asm
    sub rcx, 0x4   ; RCX = n_args - 4
    jle skip       ; 如果参数 ≤ 4，跳过搬运

    ; ... (rep movsq 搬运栈上多余参数) ...
    ; 这段使用 RCX 作为循环计数器
```

- `RCX` 在此过程中被消耗，最终变为 0 或负数。

---

##### 4. 恢复与准备跳转

```asm
skip:
    mov rcx, r12           ; ← 关键：把 syscall_addr 从 R12 移回 RCX
    mov rsi, [rsp - 0x8]   ; 恢复 RSI
    mov rdi, [rsp - 0x10]  ; 恢复 RDI
    mov r12, [rsp - 0x18]  ; 恢复 R12（遵守 Callee-saved 约定）
    jmp rcx                ; ← 跳转到 RCX，即 syscall_addr
```

> 注意顺序：**先将 `R12` 的内容移到 `RCX`，再恢复 `R12` 原值**。这样既保留了跳转地址，又满足了调用约定。

---

##### 总结：为什么绕这么一大圈？

1. **刚进来时**，`RDX` 是目标地址（`syscall_addr`）。  
2. **为了腾出 `RDX`** 给系统调用的第 2 个参数，必须把 `syscall_addr` 暂存 → 选用了 `R12`（非易失性寄存器）。  
3. **中间用 `RCX` 做了计数器**（因 `SSN` 已移至 `EAX`，`RCX` 空闲）。  
4. **函数结束前**，把 `R12` 中的地址移回 `RCX`（因为 `jmp` 需要一个寄存器操作数）。  
5. **恢复 `R12` 原值**，确保不破坏调用者上下文。  
6. **最后 `jmp rcx`** → 跳转到 `ntdll.dll` 中合法的 `syscall` 指令。

> **为什么要这么绕？**  
> 因为：
> - `jmp` 指令通常通过寄存器间接跳转（`jmp reg`），而不能直接从栈或内存跳转（效率/编码限制）；  
> - **`R12` 必须恢复**（它是 Callee-saved 寄存器），不能带着“脏数据”返回；  
> - 所以必须先把地址转移到一个“临时可用”的寄存器（如 `RCX`），再恢复 `R12`，最后跳转。

✅ 最终，`jmp rcx` 确实跳转到了传入的 `syscall_addr` —— 即 `ntdll.dll` 内部那条干净的 `syscall` 指令，从而实现**间接系统调用 + EDR 规避**。

#### 参数重映射（核心逻辑）

此时 Rust 传入的参数在：  
`RCX(ssn)`, `RDX(addr)`, `R8(n_args)`, `R9(arg1)`, `[RSP+0x28](arg2)`, ...

```asm
    mov eax, ecx       ; 1. 设置 SSN。将 ssn (RCX) 放入 EAX（内核约定的 SSN 寄存器）
    mov r12, rdx       ; 2. 保存跳转地址。将 syscall_addr (RDX) 暂存到 R12（防止被覆盖）
    mov rcx, r8        ; 3. 设置循环计数。将 n_args (R8) 放入 RCX，用于后面处理栈参数

    mov r10, r9        ; 4. 设置 Arg1。将 arg1 (R9) 放入 R10（内核约定的 Arg1）
    mov rdx,  [rsp + 0x28] ; 5. 设置 Arg2。从栈上取 arg2（Rust传参的第5个位置）放入 RDX
    mov r8,   [rsp + 0x30] ; 6. 设置 Arg3。从栈上取 arg3 放入 R8
    mov r9,   [rsp + 0x38] ; 7. 设置 Arg4。从栈上取 arg4 放入 R9
```

到这里，`EAX`（SSN）和前 4 个参数（`R10`, `RDX`, `R8`, `R9`）已经完全符合 `syscall` 指令的要求。

---

#### 处理栈上参数（Arg5+）

如果实际系统调用的参数超过 4 个，需要将它们搬运到正确的位置。

```asm
    sub rcx, 0x4       ; 剩余参数个数 = 总参数 - 4
    jle skip           ; 如果没有剩余参数，跳过搬运

    lea rsi,  [rsp + 0x40] ; 源地址：Rust传入的 arg5 的位置
    lea rdi,  [rsp + 0x28] ; 目标地址：内核期望 arg5 所在的位置（Shadow Space 之后）

    rep movsq          ; 循环复制 RCX 个 64位字 (QWORD)
```

这段代码做了一个精妙的**栈压缩操作**。

- **Rust 调用的栈帧**是：`[Shadow Space] [Arg2] [Arg3] [Arg4] [Arg5]...`
- **内核期望的栈帧**是：`[Shadow Space] [Arg5]...`

因为它把前 3 个“元数据参数”（`ssn`, `addr`, `n_args`）剥离了，所以需要把后面的参数（从 `Arg5` 开始）向前移动，覆盖掉之前 `Arg2` 等所在的位置。

> ⚠️ 注意：`rep movsq` 是高效的块复制指令，每次复制 8 字节（QWORD），共复制 `rcx` 次。

---

#### 执行跳转

```asm
skip:
    mov rcx, r12      ; 恢复 syscall_addr 到 RCX（准备跳转）

    ; 恢复之前保存的寄存器
    mov rsi, [rsp - 0x8]
    mov rdi, [rsp - 0x10]
    mov r12, [rsp - 0x18]

    jmp rcx           ; 跳转执行!
```

这里使用 `jmp` 而不是 `call`。这是一种**尾调用（Tail Call）**。

- `syscall_addr` 通常指向 `ntdll.dll` 中某函数（如 `NtCreateFile`）内部的 `syscall` 指令处。
- 当那里的 `syscall` 执行完毕并 `ret` 时，它会**直接返回到调用 `do_syscall` 的 Rust 代码处**（因为栈上的返回地址从未改变）。

> ✅ **规避优势**：整个过程**没有调用任何 Windows API 函数**，只是跳转到 `ntdll` 中的 `syscall` 指令，从而绕过了对 API 入口的 Hook。

---

## 3. x86 (32-bit) 汇编简述

32 位部分 (`_do_syscall`) 处理了更加复杂的兼容性问题：

- 它检查 `fs:[0xC0]`，这是 **WoW64**（Windows on Windows 64）的标志位。
- 如果在 64 位系统上运行 32 位程序，它需要通过“**天堂之门**（Heaven's Gate）”或特殊的 WoW64 转换层来执行系统调用。
- 代码手动构建栈帧并根据运行环境选择跳转到**原生执行**或 **WoW64 转换接口**。

---

## 总结

这段代码实现了一个**通用的、底层的系统调用发射器**。

- **目的**：让 Rust 代码可以直接通过 SSN 执行内核功能，而不必调用 Windows API 函数，从而绕过安全软件对 API 函数入口的监控（Hooking）。
- **亮点**：通过精细的栈操作，在**不分配新栈帧**的情况下，将 Rust 函数的参数列表动态转换为内核系统调用的参数列表。
- **适用场景**：红队工具、EDR 规避、底层系统编程、安全研究等需要直接与 Windows 内核交互的场景。

> 🔒 **注意**：此类技术仅应用于合法授权的安全研究、渗透测试或系统开发。未经授权的使用可能违反法律和道德准则。



### 代码逻辑分析：为什么要碰这三个？

这段代码为了实现“间接系统调用”，需要搬运参数。正是这个搬运过程使用了 `RSI`, `RDI`, `R12`。

#### A. 为什么保存 `RSI` 和 `RDI`？

代码中有这样一段关键逻辑（用于当参数超过 4 个时，搬运栈上的参数）：

```asm
lea rsi, [rsp + 0x40]  ; 源地址 -> RSI
lea rdi, [rsp + 0x28]  ; 目的地址 -> RDI
rep movsq              ; 核心指令：复制内存
```

- **`rep movsq` 指令的副作用**：  
  这条指令会不断地把 `[RSI]` 的内容复制到 `[RDI]`，并且自动修改 `RSI` 和 `RDI` 的值（让它们指向下一个地址），直到 `RCX` 计数器归零。
- **后果**：执行完这句话，`RSI` 和 `RDI` 的值就变了（被污染了）。
- **结论**：因为 `RSI` 和 `RDI` 是非易失性的，且被 `rep movsq` 修改了，所以必须在开头保存，结尾恢复。

#### B. 为什么保存 `R12`？

代码需要腾出 `RDX` 寄存器，因为系统调用本身需要 `RDX`，但函数的输入参数 `syscall_addr`（跳转地址）也存在 `RDX` 里。

```asm
mov r12, rdx           ; 把跳转地址从 RDX 备份到 R12
...
mov rdx, [rsp + 0x28]  ; RDX 被拿去装系统调用的第 2 个参数了（覆盖了原值）
...
mov rcx, r12           ; 后面跳转时，从 R12 拿回地址
jmp rcx
```

- **资源冲突**：也就是通常说的“寄存器不够用了”。为了给系统调用参数让路，必须找个地方暂存 `syscall_addr`。
- **选择 `R12`**：作者选择了 `R12` 作为临时暂存区。
- **结论**：`R12` 属于非易失性寄存器。既然你把 `R12` 覆盖成了跳转地址，为了不破坏上层函数的环境，必须先保存它的旧值，最后再恢复。

#### C. 为什么不保存 `RBX`, `R13`, `R14`, `R15`？

因为这段汇编代码压根没有碰它们。

- 代码不需要那么多临时变量，没用到 `RBX` 等。
- 既然没修改，它们的值自然保持不变。
- 不需要保存，也就省去了 `mov` 指令的开销。

---

### 总结

这三个寄存器被选中并不是随机的，而是由指令需求决定的：

1. **`RSI`, `RDI`**：因为用了 `rep movsq` 进行内存拷贝。  
2. **`R12`**：因为需要一个安全的寄存器暂存跳转地址（`syscall_addr`）。

除此之外的其他非易失性寄存器没有被修改，所以不需要保存。

---

## `RSI`、`RDI`、`R12` 这三个寄存器能不能更改？

### 寄存器选择的底层逻辑：硬件约束 vs 程序员自由

这三个寄存器（`RSI`, `RDI`, `R12`）的选用，主要取决于 **汇编指令的硬件要求** 和 **程序员的个人偏好**。我们可以将它们清晰地分为两类来看：

---

### `RSI` 和 `RDI`：硬件指令的“硬性绑定”（Hard Constraint）

> **能不能换？几乎不能**（除非你重写整个拷贝逻辑）

#### 原因

代码中使用了 `rep movsq` 这条指令来实现参数在栈上的批量拷贝。

- 在 x86/x64 汇编中，`rep movsq` 是**硬编码的字符串操作指令**：
  - 它**必须**从 `RSI` 指向的地址读取数据（源指针）
  - 它**必须**把数据写入 `RDI` 指向的地址（目标指针）
  - CPU **不认** `RBX`、`R12` 或其他寄存器做这个操作

#### 替代方案的成本

如果你想避开 `RSI`/`RDI`，就不能用高效的 `rep movsq`，而必须手写循环：

```asm
loop_start:
    mov rax, [rbx]   ; 假设用 RBX 代替 RSI
    mov [r13], rax   ; 假设用 R13 代替 RDI
    add rbx, 8
    add r13, 8
    dec rcx
    jnz loop_start
```

这样做会带来以下问题：

- **代码体积增大**：不利于 shellcode 或隐蔽载荷  
- **性能可能下降**：`rep movsq` 在现代 CPU 上有硬件优化  
- **仍需保存寄存器**：你还是得保存 `RBX` 和 `R13`，并未减少开销

✅ **结论**：保留 `RSI` 和 `RDI` 是最优解，这是由 x86 架构的硬件设计决定的。

---

### `R12`：程序员的“任意选择”（Soft Choice）

> **能不能换？完全可以！**

#### 原因

`R12` 在这里的作用**仅仅是一个“临时仓库”**。

- 因为 `RDX`（原本存放 `syscall_addr`）要被拿去装系统调用的**第 2 个参数**
- 所以必须把 `syscall_addr` 转移到一个**非易失性寄存器**里暂存

#### 可选的替代寄存器

程序员选了 `R12`，但他完全可以从以下任一非易失性寄存器中选择，效果完全相同：

- `RBX`
- `R13`
- `R14`
- `R15`

#### 演示：将 `R12` 替换为 `RBX`

只需将所有 `R12` 替换为 `RBX`，逻辑依然成立：

```asm
do_syscall:
    mov [rsp - 0x8],  rsi
    mov [rsp - 0x10], rdi
    mov [rsp - 0x18], rbx   ; ← 以前是 R12，现在改成 RBX（保存旧值）

    mov eax, ecx
    mov rbx, rdx            ; ← 把跳转地址存入 RBX
    mov rcx, r8
    ; ...（中间逻辑不变）...
    
    mov rcx, rbx            ; ← 从 RBX 拿回跳转地址

    mov rsi, [rsp - 0x8]
    mov rdi, [rsp - 0x10]
    mov rbx, [rsp - 0x18]   ; ← 恢复 RBX 的旧值

    jmp rcx
```

✅ **结论**：`R12` 的选择是**风格或习惯问题**，无技术强制性。

### 