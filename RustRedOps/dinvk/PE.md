# 关于汇编和PE文件的基础知识

## 本项目中/src/syscall/asm.rs涉及的基础知识

### 关于间接系统调用（Indirect Syscalls）

在红队操作（RedOps）和 EDR 规避技术中，直接调用 Windows API（如 CreateFile）或甚至是底层的 NtCreateFile 都可能被安全软件（EDR/AV）在用户模式下挂钩（Hook）并监控。为了绕过这些监控，该代码实现了手动设置 CPU 寄存器并跳转到 ntdll.dll 中的 syscall 指令地址执行，从而避开函数入口处的 Hook。

```rust
extern "C" {
    pub fn do_syscall(
        ssn: u16,          // 参数 1 (rcx): 系统服务号 (System Service Number)
        syscall_addr: u64, // 参数 2 (rdx): syscall 指令的内存地址
        n_args: u32,       // 参数 3 (r8) : 实际系统调用的参数个数
        ...                // 参数 4+ (r9, stack): 实际传递给系统调用的参数 (arg1, arg2...)
    ) -> i32;
}
```

这个函数的签名非常特殊。它是一个“垫片”函数，负责接收参数，重新排列它们以符合 Windows 系统调用的内核约定，然后跳转执行。

### 关于该文件中的x86_64汇编代码

Windows x64 的调用约定（Calling Convention）与 Linux 不同：

- **函数调用约定**：前 4 个参数在 `RCX`, `RDX`, `R8`, `R9`，其余在栈上。
- **Syscall 内核约定**：`syscall` 指令执行时，内核期望：
  - `EAX` = 系统服务号 (SSN)
  - `R10` = 第 1 个参数（原 `RCX` 的值，因为 `syscall` 指令会破坏 `RCX`）
  - `RDX` = 第 2 个参数
  - `R8`  = 第 3 个参数
  - `R9`  = 第 4 个参数
  - 栈    = 第 5 个及后续参数

windows的函数调用约定与内核层的syscall内核约定指令不同,内核层的 syscall 指令有特殊的硬件行为，导致这一约定必须改变.在此处更改的寄存器不是本项目的特例,而常见现象:  
Windows 的应用层函数调用约定（Win64 ABI）规定前四个参数是 RCX, RDX,R8,R9  

- 硬件原因（Syscall 指令的行为）,当 CPU 执行 syscall 指令时，硬件会自动执行以下操作：：
  1. 将当前的指令指针（RIP，即下一条指令的地址）保存到 `RCX` 中
  2. 将当前的标志寄存器（RFLAGS）保存到 `R11` 中
  3. 跳转到内核模式（Ring 0）

- 冲突点
如上,如果按照应用层约定，第 1 个参数存放在 RCX 中。但是 syscall指令一执行，`RCX`的值就会被硬件瞬间覆盖掉（变成了返回地址?这时候不是将RIP,下一条指令的地址保存进来了?怎么变成了返回地址?）。如果内核进去后读取RCX，读到的不是参数，而是返回地址。

- 解决方案（Windows 内核约定）：
为了避免参数丢失，Windows 内核约定：在执行 syscall 之前，必须把第 1个参数从 RCX 移动到 R10。内核进入后，会从 R10 读取第 1 个参数，从 RDX 读取第 2个参数，依此类推?后续是否遵循从4个寄存器读取参数?还是只对R10和rdx循环读取参数

**所以，任何程序（包括Chrome、Notepad、甚至是恶意软件）只要想直接发起系统调用，都必须执行 mov r10, rcx**

#### 代码逐行解析

##### 保存非易失性寄存器

```asm
do_syscall:
    mov [rsp - 0x8],  rsi
    mov [rsp - 0x10], rdi
    mov [rsp - 0x18], r12
```

这里非常规地将 `rsi`, `rdi`, `r12`（这些是“被调用者保存”的寄存器）保存到了栈顶下方（Shadow Space 区域或者更低）。这是为了在函数结束前恢复它们，保证不破坏调用者的环境。

> ✅ **关键点**：虽然 `rsi`/`rdi` 在 Windows x64 中不是标准 callee-saved 寄存器，但某些上下文（如 Rust 编译器生成的代码）可能依赖其值不变，因此保守保存。

#### 被调用者还需要其他非易失性寄存器来存储被调用者的信息吗?只需要这三个吗?

在 x86-64 架构中（以 System V ABI 为例），属于被调用者保存（Callee-Saved）的寄存器一共有 6 个：RBX,RBP,R12,R13,R14,R15

如果你的代码里只保存了前三个（比如 RBX, R12, R13），这隐含了一个非常重要的前提：  
`do_syscall` 这个函数的编写者（或者是编译器）承诺：在该函数的执行过程中，绝对不会修改 `RBP`, `R14`, 和 `R15` 的值。

那些没有被保存到栈上的寄存器（比如 R14），在do_syscall 执行期间，它们的值仍然安稳地待在 CPU的物理寄存器里，保持不变。  

- 调用前： R14 的值是 A（属于上层函数）。
- `do_syscall` 执行中： 因为代码逻辑没有碰 R14，R14 的值依然是 A。
- 返回后： 上层函数继续执行，读取 R14，发现还是 A。
只要不碰它，就不需要保存它。 这是一种性能优化，避免不必要的内存读写。

特殊情况区分：函数调用 vs 任务切换  
有一个极易混淆的概念，取决于你当前的上下文是在做一个普通的函数调用，还是在做一个任务切换（Context Switch）

1. 普通函数调用 / 系统调用处理函数 (Trampoline),只需要保存本函数会覆盖掉的那些寄存器。如果只用了 3 个，就只存 3 个。剩下的保持原样即可
2. 任务切换 (Task/Thread Switching)必须全部保存,如果你是要暂停当前进程 A，去运行进程 B。那你必须把进程 A 的所有通用寄存器（包括所有的 Callee-Saved寄存器，甚至包括栈指针 SP 和指令指针 IP）全部保存到内存里。

- 为什么？ 因为当 CPU 转去运行进程 B 时，进程 B 可能会把 CPU里所有的寄存器都改写一遍。如果不全部存下来，等下次切回进程 A 时，进程 A 的状态就丢了。

在 Microsoft x64 调用约定中：

- 易失性寄存器（可随意修改）： RAX, RCX, RDX, R8, R9, R10, R11。
- 非易失性寄存器（必须保存并恢复）： RBX, RBP, RDI, RSI, R12, R13, R14, R15。
规则是：如果你在函数里用到了“非易失性”列表里的寄存器，你就必须保存它；如果你没碰它，就不需要保存。

#### 代码逻辑分析：为什么要碰这三个？

这段代码为了实现“间接系统调用”，需要搬运参数。正是这个搬运过程使用了 RSI, RDI, R12。

  A. 为什么保存 RSI 和 RDI？
  代码中有这样一段关键逻辑（用于当参数超过 4 个时，搬运栈上的参数）：

   1 lea rsi,  [rsp + 0x40]  ; 源地址 -> RSI
   2 lea rdi,  [rsp + 0x28]  ; 目的地址 -> RDI
   3 rep movsq               ; 核心指令：复制内存

- `rep movsq` 指令的副作用： 这条指令会不断地把 [RSI] 的内容复制到 [RDI]，并且自动修改 `RSI` 和 `RDI`的值（让它们指向下一个地址），直到 RCX 计数器归零。
- 后果： 执行完这句话，RSI 和 RDI 的值就变了（被污染了）。
- 结论： 因为 RSI 和 RDI 是非易失性的，且被 rep movsq 修改了，所以必须在开头保存，结尾恢复。

  B. 为什么保存 R12？
  代码需要腾出 RDX 寄存器，因为系统调用本身需要 RDX，但函数的输入参数 syscall_addr（跳转地址）也存在 RDX 里。

   1 mov r12, rdx      ; 把跳转地址从 RDX 备份到 R12
   2 ...
   3 mov rdx,  [rsp + 0x28] ; RDX 被拿去装系统调用的第 2 个参数了（覆盖了原值）
   4 ...
   5 mov rcx, r12      ; 后面跳转时，从 R12 拿回地址
   6 jmp rcx

- 资源冲突： 也就是通常说的“寄存器不够用了”。为了给系统调用参数让路，必须找个地方暂存 syscall_addr。
- 选择 `R12`： 作者选择了 R12 作为临时暂存区。
- 结论： R12 属于非易失性寄存器。既然你把 R12覆盖成了跳转地址，为了不破坏上层函数的环境，必须先保存它的旧值，最后再恢复。

  1. 为什么不保存 RBX, R13, R14, R15？
  因为这段汇编代码压根没有碰它们。

- 代码不需要那么多临时变量，没用到 RBX 等。
- 既然没修改，它们的值自然保持不变。
- 不需要保存，也就省去了 mov 指令的开销。

  总结
  这三个寄存器被选中并不是随机的，而是由指令需求决定的：

   1. `RSI`, `RDI`：因为用了 rep movsq 进行内存拷贝。
   2. `R12`：因为需要一个安全的寄存器暂存跳转地址（syscall_addr）。

除此之外的其他非易失性寄存器没有被修改，所以不需要保存。

### rsi rdi r12这三个寄存器能不能更改

#### 寄存器选择的底层逻辑：硬件约束 vs 程序员自由

这三个寄存器（`RSI`, `RDI`, `R12`）的选用，主要取决于 **汇编指令的硬件要求** 和 **程序员的个人偏好**。我们可以将它们清晰地分为两类来看：

---

##### `RSI` 和 `RDI`：硬件指令的“硬性绑定”（Hard Constraint）

> **能不能换？几乎不能**（除非你重写整个拷贝逻辑）

###### 原因

代码中使用了 `rep movsq` 这条指令来实现参数在栈上的批量拷贝。

- 在 x86/x64 汇编中，`rep movsq` 是**硬编码的字符串操作指令**：
  - 它**必须**从 `RSI` 指向的地址读取数据（源指针）
  - 它**必须**把数据写入 `RDI` 指向的地址（目标指针）
  - CPU **不认** `RBX`、`R12` 或其他寄存器做这个操作

###### 替代方案的成本

如果你想避开 `RSI`/`RDI`，就不能用高效的 `rep movsq`，而必须手写循环：

```asm
loop_start:
    mov rax, [rbx]   ; 假设用 RBX 代替 RSI
    mov [r13], rax   ; 假设用 R13 代替 RDI
    add rbx, 8
    add r13, 8
    dec rcx
    jnz loop_start
```

这样做会带来以下问题：
- **代码体积增大**：不利于 shellcode 或隐蔽载荷
- **性能可能下降**：`rep movsq` 在现代 CPU 上有硬件优化
- **仍需保存寄存器**：你还是得保存 `RBX` 和 `R13`，并未减少开销

✅ **结论**：保留 `RSI` 和 `RDI` 是最优解，这是由 x86 架构的硬件设计决定的。

---

##### `R12`：程序员的“任意选择”（Soft Choice）

> **能不能换？完全可以！**

###### 原因

`R12` 在这里的作用**仅仅是一个“临时仓库”**。

- 因为 `RDX`（原本存放 `syscall_addr`）要被拿去装系统调用的**第 2 个参数**
- 所以必须把 `syscall_addr` 转移到一个**非易失性寄存器**里暂存

###### 可选的替代寄存器

程序员选了 `R12`，但他完全可以从以下任一非易失性寄存器中选择，效果完全相同：
- `RBX`
- `R13`
- `R14`
- `R15`

###### 演示：将 `R12` 替换为 `RBX`

只需将所有 `R12` 替换为 `RBX`，逻辑依然成立：

```asm
do_syscall:
    mov [rsp - 0x8],  rsi
    mov [rsp - 0x10], rdi
    mov [rsp - 0x18], rbx   ; ← 以前是 R12，现在改成 RBX（保存旧值）

    mov eax, ecx
    mov rbx, rdx            ; ← 把跳转地址存入 RBX
    mov rcx, r8
    ; ...（中间逻辑不变）...
    
    mov rcx, rbx            ; ← 从 RBX 拿回跳转地址

    mov rsi, [rsp - 0x8]
    mov rdi, [rsp - 0x10]
    mov rbx, [rsp - 0x18]   ; ← 恢复 RBX 的旧值

    jmp rcx
```

✅ **结论**：`R12` 的选择是**风格或习惯问题**，无技术强制性。

---

##### 函数签名真正决定了什么？

你的 Rust 函数签名：

```rust
pub fn do_syscall(ssn: u16, syscall_addr: u64, n_args: u32, ...)
```

根据 **Windows x64 ABI**，它只决定了**参数刚进入函数时的初始位置**：

| 参数 | Rust 名称 | 初始寄存器 |
|------|-----------|------------|
| 第1个 | `ssn` | `RCX` |
| 第2个 | `syscall_addr` | `RDX` |
| 第3个 | `n_args` | `R8` |
| 第4个 | （第一个实际 syscall 参数）| `R9` |

###### 代码的核心挑战：“大挪移”

Windows 系统调用底层（`syscall` 指令）要求的寄存器布局是：

| 目标用途 | 所需寄存器 | 值来源 |
|----------|------------|--------|
| 系统服务号（SSN） | `RAX` | 来自 `RCX` |
| 参数1 | `R10` | 来自 `R9` |
| 参数2 | `RDX` | 来自栈上 `[rsp + 0x28]` |
| 参数3 | `R8` | 来自栈上 `[rsp + 0x30]` |
| 参数4 | `R9` | 来自栈上 `[rsp + 0x38]` |

###### 关键冲突点

- **输入**：`RDX` 存的是 `syscall_addr`（跳转地址）
- **输出**：`RDX` 必须存系统调用的**第 2 个参数**
- **冲突！** → 必须先把 `syscall_addr` 移走

###### 解决方案

- 把 `syscall_addr` 暂存到一个**不会被后续操作覆盖的寄存器**
- 最安全的选择是**非易失性寄存器**（`RBX`, `R12`–`R15`）
- 这就是为什么需要 `R12`（或其等价物）

---

##### 总结

| 寄存器 | 选择原因 | 是否可替换 | 替换代价 |
|--------|----------|------------|----------|
| `RSI` / `RDI` | `rep movsq` 指令的硬件强制要求 | ❌ 几乎不可 | 需重写拷贝逻辑，代码变长、变慢 |
| `R12` | 临时存储 `syscall_addr` 的便利选择 | ✅ 完全可以 | 无，可换成 `RBX`/`R13`/`R14`/`R15` |

> 🔑 **核心洞见**：  
> **函数签名只规定“原材料进来时放哪儿”，不规定“加工过程中用什么工具”。**  
> 寄存器的中间使用完全是实现细节，只要最终满足 `syscall` 的输入约定，并遵守调用约定的保存规则即可。

#### 参数重映射（核心逻辑）

此时 Rust 传入的参数在：  
`RCX(ssn)`, `RDX(addr)`, `R8(n_args)`, `R9(arg1)`, `[RSP+0x28](arg2)`, ...

```asm
    mov eax, ecx       ; 1. 设置 SSN。将 ssn (RCX) 放入 EAX（内核约定的 SSN 寄存器）
    mov r12, rdx       ; 2. 保存跳转地址。将 syscall_addr (RDX) 暂存到 R12（防止被覆盖）
    mov rcx, r8        ; 3. 设置循环计数。将 n_args (R8) 放入 RCX，用于后面处理栈参数

    mov r10, r9        ; 4. 设置 Arg1。将 arg1 (R9) 放入 R10（内核约定的 Arg1）
    mov rdx,  [rsp + 0x28] ; 5. 设置 Arg2。从栈上取 arg2（Rust传参的第5个位置）放入 RDX
    mov r8,   [rsp + 0x30] ; 6. 设置 Arg3。从栈上取 arg3 放入 R8
    mov r9,   [rsp + 0x38] ; 7. 设置 Arg4。从栈上取 arg4 放入 R9
```

到这里，`EAX`（SSN）和前 4 个参数（`R10`, `RDX`, `R8`, `R9`）已经完全符合 `syscall` 指令的要求。

---

#### 处理栈上参数（Arg5+）

如果实际系统调用的参数超过 4 个，需要将它们搬运到正确的位置。

```asm
    sub rcx, 0x4       ; 剩余参数个数 = 总参数 - 4
    jle skip           ; 如果没有剩余参数，跳过搬运

    lea rsi,  [rsp + 0x40] ; 源地址：Rust传入的 arg5 的位置
    lea rdi,  [rsp + 0x28] ; 目标地址：内核期望 arg5 所在的位置（Shadow Space 之后）

    rep movsq          ; 循环复制 RCX 个 64位字 (QWORD)
```

这段代码做了一个精妙的**栈压缩操作**。

- **Rust 调用的栈帧**是：`[Shadow Space] [Arg2] [Arg3] [Arg4] [Arg5]...`
- **内核期望的栈帧**是：`[Shadow Space] [Arg5]...`

因为它把前 3 个“元数据参数”（`ssn`, `addr`, `n_args`）剥离了，所以需要把后面的参数（从 `Arg5` 开始）向前移动，覆盖掉之前 `Arg2` 等所在的位置。

> ⚠️ 注意：`rep movsq` 是高效的块复制指令，每次复制 8 字节（QWORD），共复制 `rcx` 次。

---

#### 执行跳转

```asm
skip:
    mov rcx, r12      ; 恢复 syscall_addr 到 RCX（准备跳转）

    ; 恢复之前保存的寄存器
    mov rsi, [rsp - 0x8]
    mov rdi, [rsp - 0x10]
    mov r12, [rsp - 0x18]

    jmp rcx           ; 跳转执行!
```

这里使用 `jmp` 而不是 `call`。这是一种**尾调用（Tail Call）**。

- `syscall_addr` 通常指向 `ntdll.dll` 中某函数（如 `NtCreateFile`）内部的 `syscall` 指令处。
- 当那里的 `syscall` 执行完毕并 `ret` 时，它会**直接返回到调用 `do_syscall` 的 Rust 代码处**（因为栈上的返回地址从未改变）。

> ✅ **规避优势**：整个过程**没有调用任何 Windows API 函数**，只是跳转到 `ntdll` 中的 `syscall` 指令，从而绕过了对 API 入口的 Hook。

---

## 3. x86 (32-bit) 汇编简述

32 位部分 (`_do_syscall`) 处理了更加复杂的兼容性问题：

- 它检查 `fs:[0xC0]`，这是 **WoW64**（Windows on Windows 64）的标志位。
- 如果在 64 位系统上运行 32 位程序，它需要通过“**天堂之门**（Heaven's Gate）”或特殊的 WoW64 转换层来执行系统调用。
- 代码手动构建栈帧并根据运行环境选择跳转到**原生执行**或 **WoW64 转换接口**。

---

## 总结

这段代码实现了一个**通用的、底层的系统调用发射器**。

- **目的**：让 Rust 代码可以直接通过 SSN 执行内核功能，而不必调用 Windows API 函数，从而绕过安全软件对 API 函数入口的监控（Hooking）。
- **亮点**：通过精细的栈操作，在**不分配新栈帧**的情况下，将 Rust 函数的参数列表动态转换为内核系统调用的参数列表。
- **适用场景**：红队工具、EDR 规避、底层系统编程、安全研究等需要直接与 Windows 内核交互的场景。

> 🔒 **注意**：此类技术仅应用于合法授权的安全研究、渗透测试或系统开发。未经授权的使用可能违反法律和道德准则。
