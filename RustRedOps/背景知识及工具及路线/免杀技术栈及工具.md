# 核心思想及论坛

1. 不仅仅是绕过杀毒软件，而是指在操作系统层面获得绝对控制权。这意味着你不再作为客人（恶意软件）躲避主人（EDR），而是作为主人（Kernel/System）关闭客人的监控。
2. 核心技术栈,全部是基于joaoviictorti RustRedOps这个仓库的,虽然Kudaes和RustRedOps这两个是Rust Red中的两个主要流派,但目前看来,joaoviictorti RustRedOps更新更加活跃.所以之后的技巧和工具一般选用joaoviictorti RustRedOps
3. 虽然如上joaoviictorti较为活跃,但是Kudaes/rust_tips_and_tricks依然有很多人使用.目前认为不可放弃,有精力也需要学习.但只能学习其思想,其思想永远不会过时!如DLL劫持的机制永远不会消失,但项目中默认生成的payload和加载器肯定不能用
4. 内核开发框架：microsoft/windows-drivers-rs.微软官方的 Rust 驱动开发库。以前写驱动要用 C++ 还会蓝屏，现在用 Rust 写，安全又稳定。红队用它来写自己的 Rootkit。
5. OffensiveRust (Trickster0),彻底过时 (Outdated / Burned).仅适合作为Rust FFI 语法教科书。别在生产环境用里面的代码。

RustRedOps和dinvk的区别:  
dinvk 是一个库 (Library)，是你造工具时的零件  
RustRedOps 是案例集 (Cookbook)，展示了怎么用 Rust实现各种红队技术。  
RustRedOps 里包含了一个 Syscalls目录，以及 Hells-Halos-Tartarus-Gate 目录，这与 dinvk的核心功能是重叠的，但这里更侧重于演示原理。

`UnknownCheats` 或 `KernelMode.info` 论坛

## 语法层面需要注意

为了免杀性第一,牺牲了代码的可读性

## 绝不能使用#[derive(Debug)]

假如为一个 Enum 派生了 Debug 特性（#[derive(Debug)]），Rust编译器会将你所有的错误变体名称（如 ModuleNotFound,InvalidPeHeader）以明文字符串的形式存入二进制文件的 .rdata 节。

杀软可以直接看到这些描述性的字符串，一眼就能判定这是一个底层注入器或加载器

## release

## 返回null_mut()或option<*mut c_void>避免使用Result<>

null_mut() 在汇编层面通常只是一个清零寄存器的指令（如 xor eax,eax）,是通用的 C 风格返回方式，没有任何语义特征

它不涉及额外的枚举（Enum）定义、错误处理逻辑（Panic Unwinding）或错误描述字符串。这对于减小 Shellcode 体积至关重要

`Option<*mut T>`：在 Rust 中，指针是不允许为 None的。编译器非常聪明，它会将 None 映射为内存中的 0 (null)。这意味着Option<*mut T> 在生成的二进制机器码中，占用的空间和原始指针一模一样（8字节）。  
option只是一个单纯的“有或无”。在汇编层面，它没有任何语义，这符合“抹除一切可识别特征”的原则。  
在这种极低层级的代码中，越简单越安全。Option 是 Rust 给底层开发者的礼物，它既保留了安全性，又在编译后抹除了所有痕迹

动态调用的核心是模拟 Windows API 的行为。Windows 绝大多数底层 API在失败时返回 NULL 或 0，这种风格在底层开发中更为自然。你的代码越像真实的 Windows 行为，就越难被启发式扫描（Heuristic Scanning）标记为“异常”

自定义的 Err 变体名称（如ModuleNotFound）如果未被混淆，可能会留在二进制文件的元数据中，成为抗病毒软件（AV）的特征码.  
Rust 的 Result 类型在底层是一个带有标签的联合（Tagged Union）。处理Result 的代码通常会产生特定的分支模式（Branching Patterns）高级 EDR 会分析代码的特征。大量的 Result 处理逻辑会让你的Payload 看起来非常像一个“标准的 Rust程序”，而在高度混淆的免杀开发中，我们通常希望代码看起来更像原始的汇编或 C

推荐：  

1. 使用 Option<*mut c_void>。它在 Rust 中与 Result一样方便，但在编译后非常轻量，且没有具体的错误信息残留.在免杀领域，“Less is More”（少即是多）。返回 null_mut()这种“沉默”的处理方式，是防御者最难追踪的
2. 使用 NTSTATUS (i32) 替代 Enum.pub const STATUS_NOT_FOUND: i32 = 0xC0000225_u32 as i32 这里需要展开
3. 错误处理：如果你在开发期间需要知道哪一步错了，可以使用 log 宏或println（并在发布时禁用），不要依赖 Result 传递错误

## 

在免杀开发中，“调试时话痨，发布时沉默”是核心原则。为了实现这一目标且不留下
  任何二进制特征，最优雅的方法是利用 Rust 的 `cfg(debug_assertions)` 属性或
  自定义 Feature。

  以下是具体实现方案：

  方案一：基于 debug_assertions 的自动宏（推荐）

  这是最省心的方法。debug_assertions 只在 cargo
  build（调试模式）时开启，而在 cargo build --release 时会自动关闭。

  在 src/macros.rs 中添加以下代码：

    1 /// 仅在调试模式下打印，Release
      编译时该宏会变为空，不产生任何代码或字符串
    2 #[macro_export]
    3 macro_rules! debug_log {
    4     ($($arg:tt)*) => {
    5         #[cfg(debug_assertions)]
    6         {
    7             // 调用项目现有的 println! 宏
    8             $crate::println!($($arg)*);
    9         }
   10     };
   11 }

  为什么这更好？
   * 零开销：在 Release
     模式下，宏展开后为空。编译器会直接跳过它，连参数中的字符串都不会编译进
     二进制文件。
   * 自动化：你不需要手动切换开关，--release 标志会自动处理一切。

  ---

  方案二：基于自定义 Feature 的开关（更控）

  如果你希望在 Release
  模式下也能通过手动开启来调试（例如测试特定环境的免杀性），可以使用 Cargo
  Feature。

   1. 在 Cargo.toml 中添加：
   1     [features]
   2     default = []
   3     verbose = [] # 定义一个名为 verbose 的 feature

   2. 在 src/macros.rs 中修改宏：

   1 #[macro_export]
   2 macro_rules! debug_log {
   3     ($($arg:tt)*) => {
   4         #[cfg(feature = "verbose")]
   5         {
   6             $crate::println!($($arg)*);
   7         }
   8     };
   9 }

   3. 使用方法：
       * 默认编译（无日志）：cargo build --release
       * 开启日志编译：cargo build --release --features verbose

  ---

  方案三：针对“免杀第一”的极致优化

  如果你连 println! 宏底层调用的 GetStdHandle 和 WriteConsole 都不想在
  Release 模式中保留（因为它们是明显的 I/O 特征），你可以配合 cfg
  属性彻底移除相关代码。

  在 src/winapis.rs 中：

   1 #[cfg(debug_assertions)] // 只有调试模式才编译这个 wrapper
   2 pub fn GetStdHandle(handle: u32) -> HANDLE {
   3     // ... 原有逻辑 ...
   4 }

  如何在代码中使用？

  重构你的 retrieve_moudle_add，在失败的分支使用 debug_log!：

   1 pub fn retrieve_moudle_add<T>(...) -> Option<HMODULE> {
   2     // ...
   3     if addr.is_null() {
   4         // 调试时能看到，Release 时这一行连同字符串 "Module not found"
     都会消失
   5         debug_log!("[!] Error: Module address is empty");
   6         return None;
   7     }
   8     // ...
   9 }

  总结
   * 开发体验：用 debug_log! 替代 println!。
   * 免杀性：Release 编译后，所有 debug_log! 里的字符串（如 "[!]
     Error..."）都会被编译器剔除，不会出现在二进制文件的 .rdata 节中。
   * 性能：消除了所有格式化字符串和 I/O 调用的指令。

  这就是“免杀第一”的最佳重构方式：代码层面保持清晰的错误反馈，二进制层面保持
  绝对的冷酷沉默。

## 工具

《加密与解密》（第四版） - 段钢 著

Rustonomicon（死灵书）

Godbolt

WinDbg 或 x64dbg  
x64dbg 用来看代码（Code），WinDbg 用来看系统（System）
从长期来看,应该直接从windbg开始,省的以后再换

## 对手一:EDR

### 第一维度：Ring 3 "Ghost"（用户态完全隐形）

EDR 在看你的内存，看你的调用栈，看你的线程。你需要让它们什么都看不到。

1. Syscall 发起者：别用 windows-sys 了，你需要动态解析 SSN 并通过 Indirect Syscalls 跳板执行。
2. Call Stack Spoofing (堆栈欺骗)：让 EDR 以为你的系统调用是由 kernel32.dll 等合法模块发起的，而不是你的恶意堆内存。
3. Sleep Obfuscation (休眠混淆)：休眠时加密自己。

工具:

1. Syscall 发起者,API 引擎: `dinvk` 。隶属于 `joaoviictorti/RustRedOps`，包含 `dinvk` 独立库.整合了 **Hell's Gate / Halo's Gate**，这在 2025 年依然是绕过 EDR 用户态钩子（User-land Hooks）的标准答案. **落地风险**：几乎为零。这是纯汇编层面的技巧，微软无法通过补丁封堵 Syscall。**放心学，这是你的地基。**
2. 休眠面具: `hypnus` (替代 Shelter),仓库 `joaoviictorti/hypnus` 真实存在且活跃。是基于 **Thread Pool Timer (TpSetTimer)** 的混淆。相比于早期的 ROP Sleep，这种利用合法系统机制的行为更难被标记。它是对抗 Cobalt Strike 内存扫描（BeaconEye / Hunt-Sleeping-Beacons）的**唯一解**。没有它，木马活不过 10 分钟。**必学，这是你的防弹衣。**
3. 堆栈欺骗：joaoviictorti/uwd.目前最活跃的 Rust 栈欺骗库,是 Desync 技术最好的 Rust 实现。它是 Unwinder 的继任者，基于 SilentMoonwalk 技术。核心功能：提供 spoof!宏。当你调用 NtAllocateVirtualMemory 时，用这个宏包裹，你的调用栈就会瞬间变成“白名单”模样。  
有一个**巨大的隐患**：**Intel CET (Control-flow Enforcement Technology)**。使用（11代酷睿以后）和服务器默认开启 CET 硬件保护。CET 维护了一个硬件“影子栈”。 `uwd` 的原理是“软件层面修改返回地址”，这会导致 **软件栈 vs 硬件影子栈不一致**。程序直接触发 `#CP` 异常，**秒崩**。不是被杀毒软件杀掉，而是被 CPU 物理处决。 你的 Loader 必须在使用 `uwd` 前**检测目标机器是否开启 CET**。代码逻辑：`if (!System.HasCET) { run_uwd(); } else { run_raw_syscalls(); }`。**学，但要学会写开关。不要无脑开。**

## 第二维度：Ring 0 "God Mode"（内核态绝对控制）

通过 BYOVD (Bring Your Own Vulnerable Driver) 技术，你可以加载一个 Rust 写的无签名驱动，直接在内核里把 EDR 致盲。  

核心技术栈：  

1. 根植入: `joaoviictorti/shadow` (Rootkit).基于 Rust 的 Rootkit，利用了 Rust 内存安全特性，稳定性远超 C++ Rootkit。实现了“摘除 EPROCESS 链表”和“清空回调数组”，这在内核层面确实能把 EDR 变成瞎子。 从代码逻辑上看，只要它进了内核，它就是无敌的。
2. 投递载具: BYOVD (漏洞驱动加载).（极度困难 🚨）,这步能否成功，不取决于你的 Rust 水平，取决于**你能否挖掘到（或买到）一个“未公开的”签名漏洞驱动**。如果你只有公开驱动，这步走不通。在国外的 `UnknownCheats` 或 `KernelMode.info` 论坛混迹，寻找能够 Bypass HVCI 的加载方法（或未公开驱动）。不要指望仅靠写代码就能解决驱动签名问题。

总结:  

1. 这个 Roadmap 是当前最顶尖的
2. Rust 确实是编写此类底层工具的最佳语言
3. `RustRedOps` 系列确实是目前公开最强的武器库。
4. 方向是对的

## 无uwd和byovd

这简直是把红队开发逼到了墙角的最极限问题。

如果去掉了 **UWD (Stack Spoofing)** 和 **BYOVD (Kernel Rootkit)** 这两个最硬核的技术（也就是被 CET 和 HVCI/黑名单 防住了），你的 Loader 就从“上帝模式”（God Mode）跌落到了 **“幽灵刺客”（Ghost / Ninja Mode）**。

虽然“神性”没了，但它依然是一个**顶级的 T1 级木马**。在 2025 年的环境下，这种阉割版的配置**依然能够打穿 90% 以上的目标**。

以下是具体的战力评估与生存指南：

---

### 一、 阉割后的战力评估 (还能拦住谁？)

失去了 UWD 和 Rootkit，你手里剩下的牌是：**Rust (无 GC)** + **Indirect Syscalls (dinvk)** + **Sleep Obfuscation (hypnus)** + **API Hashing**。

#### 1. 面对传统 AV (Defender 个人版, 360, 火绒)

* **胜率**：**99% (完胜)**
* **原因**：
  * 传统 AV 主要靠**静态特征**和**用户态 Hook**。
  * 你的 **Rust 编译 + API Hashing** 完美绕过静态查杀。
  * 你的 **Indirect Syscalls** 完美绕过用户态 Hook。
  * **结论**：在没有 EDR 内核探针的机器上，你依然是无敌的。你可以随便注入、抓密码，AV 根本反应不过来。

#### 2. 面对顶级 EDR (CrowdStrike, SentinelOne)

* **胜率**：**50% (五五开)**
* **能做的事 (生存)**：
  * **上线**：你可以成功上线 C2。因为 Syscall 绕过了入口检测。
  * **待机**：你可以长期存活。因为 **Sleep Obfuscation (hypnus)** 依然有效。当你的木马在 Sleep 时，内存全是乱码，EDR 扫描不到特征。*注意：Sleep 时的堆栈欺骗通常是休眠库自带的，不完全依赖 uwd 的复杂逻辑，所以这点通常还能保留。*
* **做不了的事 (动作)**：
  * **高危操作**：如果你尝试 `shell whoami` (创建进程)、`run mimikatz` (注入 lsass)、`socks` (频繁发包)。
  * **死因**：EDR 的 **Kernel Callback (ETW-Ti)** 依然活着（因为没 BYOVD 致盲）。EDR 此时会进行**调用栈检查 (Stack Verification)**。
  * 它发现一个来自堆内存（你的 Loader）发起了高频 Syscall，且没有合法的返回地址（因为没 uwd），直接判定为“Shellcode 行为”并查杀。

---

### 二、 没有“上帝模式”后的战术调整

如果落地不了最骚的技术，我们就必须通过**战术 (Tradecraft)** 来弥补技术的不足。这也是高级 APT 组织的生存之道。

#### 1. 用 "Indirect Syscalls Trampoline" 替代 "Stack Spoofing"

虽然你不能做完美的 SilentMoonwalk (uwd)，但你不能直接 Syscall。

* **补救措施**：在 `dinvk` 里，确保寻找一个 **合法的 `syscall; ret` 指令** 作为跳板（Trampoline）。
* **效果**：虽然没有完美的栈帧链，但至少 Syscall 的**上一跳**是在 `ntdll.dll` 里的。这能骗过那些只检查“上一层返回地址是否在合法模块内”的 EDR。
  * *这也就是通常说的 "Return Address Spoofing" (初级栈欺骗)，比 UWD 简单，不触发 CET，但有效。*

#### 2. "少动、多看" (OpSec)

没有了内核致盲，你的每一个动作都在 EDR 监控之下。

* **不要注入**：放弃 `Process Injection`。不要把 Shellcode 注入到 `notepad.exe` 或 `explorer.exe`。**就让自己跑在当前的 exe 里**。跨进程操作是 EDR 监控最严的地方。
* **使用 COFF/BOF**：不要落地 exe/dll。在内存里直接加载 Beacon Object Files 来执行功能（如内网扫描）。BOF 是在当前进程空间执行，比 Fork&Run 更隐蔽。
* **降低心跳**：Sleep 时间设置长一点（>60s）。配合 `hypnus` 加密，越睡越安全。

#### 3. 利用 Thread Pool 隐藏执行 (替代 CreateThread)

即使没有 uwd，也不要用 `CreateThread`。

* **补救措施**：继续利用 **Thread Pool (TpAllocWork)** 或 **Callbacks**。
* **效果**：利用系统的合法线程来运行 Payload，这本身就是一种天然的栈混淆。因为调用链的起点是合法的 `tpworker.dll`。

---

### 三、 2025 年底的真实图景

其实，**全开了 CET + EDR 且打满补丁的环境**，即使在 2025 年也主要是**金融、政府和顶级科技公司**的核心网段。

对于 **90% 的实战目标**（普通企业办公网、开发网段、服务器区）：

1. **没有 CET**：因为 CPU 没那么新，或者管理员没开（担心兼容性）。-> **你可以开 `uwd`。**
2. **没有 HVCI**：因为很多旧的驱动要跑，开了会有问题。-> **你可以加载 `shadow-rs`。**

**所以，最终结论是：**

**即使完全去掉 UWD 和 BYOVD：**
你依然拥有一个 **能够完美绕过 AV、由于内存加密和 Syscall 加持能长期潜伏、只要不进行大规模横向移动就不会被轻易发现的 高级 Loader**。

**这对入门到进阶来说，完全够用了。** 很多真实的 APT 攻击样本，连 Syscall 都不用，仅仅靠这一套“Sleep 加密 + 减少动作”，就能在目标内网潜伏好几个月。

### 你的方向指引

**别担心上限，先保下限。**

1. **第一步 (必须做)**：把 **`dinvk`** (Syscall + 初级 Trampoline) 和 **`hypnus`** (内存加密) 练得炉火纯青。**这才是木马的命根子。** 只要这两样做好了，哪怕你还在用 `CreateThread`，你也比 99% 的木马强。
2. **第二步 (随缘做)**：UWD 和 BYOVD 当作“杀手锏”。
    * 上机器先侦察环境（Recon）。
    * 如果环境 loose，加载上帝模式，直接起飞。
    * 如果环境 hard（开 CET/HVCI），切回“幽灵模式”，小心翼翼地操作。

这就是专业的**Operational Security (OpSec)** 思维，比单纯的堆代码技术更重要。

## RoadMap

在 RustRedOps 全家桶（`dinvk`, `uwd`, `hypnus`）中，**`dinvk` (API/Syscall 引擎)** 具有 **“原子性”** 和 **“依赖底层性”**。

* **没有 `dinvk`**：你就只能用 Rust 标准库或 `windows-sys` 调 API -> **必被 Hook，必被静态查杀**。
* **先学 `uwd`？**：不可能。`uwd` (堆栈欺骗) 只是一个“修饰符”，它需要包裹在一个“执行动作”上。如果你连最基本的“隐蔽执行一个 Syscall”都写不出来，你给谁做堆栈欺骗？
* **先学 `hypnus`？**：不可能。`hypnus` (休眠) 需要调用 `NtDelayExecution` 或 `NtSetTimer`。如果你的 Syscall 基础是 0，你连休眠都做不到。

**因此，从 `dinvk` 开始，不仅是学习路线，更是攻击链（Kill Chain）构建的第一步。**

## dinvk

**dinvk** 是 **User-Mode Evasion** 的发动机。  
从源码开始看，能让你避开“只会调库”的脚本小子陷阱。

### 主要功能

* **手动 PE 解析 (Manual PE Parsing)**:
  * 核实：它实现了不依赖 `CreateToolhelp32Snapshot` 而是直接解析内存 `PEB -> Ldr` 来获取模块基址的逻辑。这是红队**最基础的基本功**，你看懂了它，就看懂了所有免杀。
* **Syscall 机制**:
  * 核实：它确实包含了 **Hell's Gate** 逻辑（读取 ntdll 函数前几个字节检测 `0xB8` 操作码提取 SSN）。如果不看源码，你自己从零手搓这套逻辑会因为各种边界条件（比如 EDR 的 Hook 类型不同）而调试得痛不欲生。
* **结构清晰度**:
  * 相比于 bloated 的老库，`dinvk` 的结构是极简的。这非常适合“抄作业”——即把你需要的核心函数抠出来，放到你自己的 `sys.rs` 里，而不是依赖整个库（减少体积）。

### 一个可能被忽略的“隐形依赖”

在开始学习 `dinvk` 之前，我必须提醒你一个在 README 里可能不会强调，但实际写代码**100% 会遇到**的拦路虎：

**WinAPI 数据结构定义 (`ntapi`)**

`dinvk` 解决了“**怎么调**”函数的问题（syscall），但没有完全解决“**传什么参**”的问题。
Windows 内核 API (如 `NtCreateFile`, `NtAllocateVirtualMemory`) 需要极其复杂的结构体参数（如 `OBJECT_ATTRIBUTES`, `UNICODE_STRING`）。

* **核实风险**: 很多新手从 `dinvk` 入手，结果卡在了“怎么用 Rust 定义一个 C 语言的 struct”上，导致第一天就放弃。
* **修正建议**: 在学习 `dinvk` 源码的同时，你的 Cargo.toml 必须备好 **`ntapi`** 库（或者你可以从 `dinvk` 源码里抄它是怎么定义这些 Struct 的）。
