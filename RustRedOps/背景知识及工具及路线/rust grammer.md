# Rust Grammer

## 内联宏

`#[inline]`是一个编译器指令，建议编译器将该函数的代码直接“嵌入”到调用它的地方，而不是通过函数调用（Jump/Call）指令跳转执行

对于函数的操作极其简单（比如,只是把一个指针包进另一个结构体），函数调用的开销（压栈、跳转、出栈）甚至比函数体本身的逻辑还要重  

这样实现了零成本抽象（Zero-cost Abstraction）。在生成的二进制机器码中，这个函数调用通常会彻底消失，效率等同于你手动初始化结构体。

## let-else

称为“可反驳模式绑定”（Refutable Pattern Binding）  
不可反驳模式 (Irrefutable)：一定会匹配成功的模式（如普通的 let x =5;）

```rust
let <模式> = <表达式> else {
        // 当模式匹配失败时执行的代码块
       // 必须包含发散逻辑（return, break, continue, panic! 等）
    };
    // 如果匹配成功，模式中的变量在这里开始生效
```

只要 `=` 左边的“模板”没法套在右边的“实际数据”上，程序就会跳进`else` 块

一旦进入 else，你必须用 return、break 或 continue离开当前逻辑，因为 Rust 编译器需要保证：如果代码跑到了 `let-else`的下一行，左边的变量（如 `nt_header`）必须是已经成功拿到值的

它结合了 if let 的简洁模式匹配和 match的非嵌套流程控制。它专注于“快速失败”（Early Return）逻辑

### 重要特性

(1) 变量作用域（最重要）
  与 if let 不同，let-else绑定成功的变量，其作用域是在当前代码块的剩余部分，而不是在一个局部的大括号
  内。

* `if let`：变量只在 { ... } 块内有效。
* `let-else`：变量在 let-else 语句之后一直有效

(2) 必须“发散”（Diverging）

  else块中的代码绝对不能让程序流程正常“流出”到下一行。它必须通过以下方式之一结束：

* return（返回函数）
* break / continue（在循环中）
* panic!（终止程序）
* 调用返回值为 !（Never 类型）的函数

  (3) 模式匹配的强大
  它不仅支持 Some/None，还支持任何模式：

    ```rust
    // 解构元组并带条件检查
    let (Some(nt), Some(exports)) = (get_nt(), get_exports()) else {
        return;
    };
    ```

## Result<>

## derive[debug]

## pub const fn to_bytes(&self) -> &[u8]

const 关键字表示这是一个 常量函数(Constant Function)

含义和作用:  
1.  编译期求值 (Compile-time Evaluation)
允许编译器在编译阶段就执行这个函数。如果该函数的输入在编译时是已知的（例如一个硬编码的字符串字面量），那么它的结果也会在编译时直接计算出来并嵌入到二进制文件中，而不需要在程序运行时消耗 CPU 去解析

2. 用于定义常量
由于它可以在编译期求值，你可以把这个函数的结果直接赋值给全局 const 或 static变量

限制:  
const fn 内部不能执行任何无法在编译期确定的操作，例如：
* 不能进行动态内存分配（无法在 const fn 里直接 Box::new 或创建 Vec）
* 不能进行文件 I/O 或网络操作
* 只能调用其他的 const fn

**在免杀/红队开发中的实际意义**  
* 消除运行时开销：对于 API名称哈希、字符串转换等操作，如果在编译期就转换成了字节数组或哈希值，运行时就完全没有这部分逻辑的代码特征（Code Flow），减少了被 EDR 监控的机会
* 性能优化：减少了程序启动时的初始化时间，因为数据已经是“准备好”的状态
* 绕过启发式扫描：一些杀软会监控频繁的字符串处理函数调用（如 to_uppercase或复杂的转换）。使用 const fn预处理数据，意味着你的二进制文件中只剩下处理后的结果，而没有产生这些结果的可疑过程