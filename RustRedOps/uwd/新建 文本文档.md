- [src/asm/msvc/desync.asm](#srcasmmsvcdesyncasm)
    - [DQ](#dq)
  - [ROP链](#rop链)
    - [传统攻击方式失效](#传统攻击方式失效)
    - [ROP的核心突破](#rop的核心突破)
    - [ROP基础：Gadgets与链式执行](#rop基础gadgets与链式执行)
      - [Gadget](#gadget)
  - [x64架构核心寄存器详解](#x64架构核心寄存器详解)
    - [RIP](#rip)
    - [pop rdi](#pop-rdi)
    - [POP操作的是指针还是数据?](#pop操作的是指针还是数据)
  - [到底什么是栈?](#到底什么是栈)
    - [栈和栈帧](#栈和栈帧)
    - [栈的诞生：操作系统层面](#栈的诞生操作系统层面)
    - [CPU架构：硬件支持栈操作](#cpu架构硬件支持栈操作)
    - [编译器：生成栈管理代码](#编译器生成栈管理代码)
    - [四、程序启动：栈的初始化](#四程序启动栈的初始化)
    - [五、线程创建：独立栈分配](#五线程创建独立栈分配)
    - [栈的生命周期](#栈的生命周期)

# src/asm/msvc/desync.asm

```aws
;;
;; Code responsible for Call Stack Spoofing Via Desync (MASM,宏汇编程序（Macro Assembler，简称MASM）是一种支持宏指令的汇编语言处理工具) 微软的汇编
;;

;;
;; Export
;;
Spoof proto

.data

;;
;; Configuration structure passed to the spoof ASM routine
;;
;;定义了一个名为Config的汇编结构体(STRUCT)，它与Rust代码中的#[repr(C)]结构体必须字节级完全匹配
;;
;;该结构体用于构造一个欺骗性的栈布局,用于欺骗Windows异常处理机制(如SEH),构建合法的栈帧链以通过系统验证,最终执行任意函数调用(包括系统调用syscall)
;;
Config STRUCT
    ;Config结构体的一个field name,定义了该field在结构体中的位置(内存偏移位置)
    ;DQ 1,分配8字节(64位)大小的内存,初始化为1
    ;RtlUserThreadStart是Windows中真实存在的系统函数，是Windows所有用户态线程的标准入口点(当创建新线程时，系统最终会调用此函数,在异常处理中被视为高度可信的系统函数),位于ntdll.dll,Addr后缀是开发者添加的，明确表示这将存储地址
    ;这里将存储RtlUserThreadStart函数在当前进程地址空间的实际地址
    ;Windows线程入口点地址
    RtlUserThreadStartAddr       DQ 1
    ;该函数的栈帧大小
    RtlUserThreadStartFrameSize  DQ 1
    
    ;Win32线程初始化函数(根据上下文确定是函数的,本身这个字段没有函数或数据的意义表达)地址
    BaseThreadInitThunkAddr      DQ 1
    ;该函数的栈帧大小
    BaseThreadInitThunkFrameSize DQ 1
    ;以上,创建两个系统级函数的假栈帧，使异常处理机制认为当前执行流程是合法的系统线程
    ;Windows在异常处理时会遍历栈帧，这些伪造的帧让系统认为ROP链是正常线程执行流程

    ;程序有一个物理栈和多个逻辑栈.函数调用会在该栈上创建多个栈帧.
    ;FirstFrame/SecondFrame,不是两个不同的栈，而是同一个栈上两个连续的栈帧区域(栈帧和栈的区别见下面)
    ;这两个字段存储的是栈上特定位置的地址，共同构成一个连续的、看似合法的调用链
    FirstFrame                   DQ 1
    SecondFrame                  DQ 1
    JmpRbxGadget                 DQ 1
    AddRspXGadget                DQ 1

    FirstFrameSize               DQ 1
    SecondFrameSize              DQ 1
    JmpRbxGadgetFrameSize        DQ 1
    AddRspXGadgetFrameSize       DQ 1

    RbpOffset                    DQ 1

    SpooFunction                 DQ 1
    ReturnAddress                DQ 1

    IsSyscall                    DD 0
    Ssn                          DD 0

    NArgs                        DQ 1
    Arg01                        DQ 1
    Arg02                        DQ 1
    Arg03                        DQ 1
    Arg04                        DQ 1
    Arg05                        DQ 1
    Arg06                        DQ 1
    Arg07                        DQ 1
    Arg08                        DQ 1
    Arg09                        DQ 1
    Arg10                        DQ 1
    Arg11                        DQ 1
Config ENDS

.code

;;
;; Function responsible for Call Stack Spoofing
;;
Spoof PROC
    ;;
    ;; Saving non-vol registers
    ;;
    push rbp
    push rbx

    ;;
    ;; Return main 
    ;;
    mov rbp, rsp 

    ;;
    ;; Creating stack pointer to Restore PROC
    ;;
    lea rax, Restore
    push rax
    lea rbx, [rsp]

    ;;
    ;; First Frame (Fake origin)
    ;;
    push [rcx].Config.FirstFrame

    mov rax, [rcx].Config.ReturnAddresS
    sub rax, [rcx].Config.FirstFrameSize

    sub rsp, [rcx].Config.SecondFrameSize
    mov r10, [rcx].Config.RbpOffset
    mov [rsp + r10], rax
    
    ;;
    ;; ROP Frames
    ;;
    push [rcx].Config.SecondFrame

    ;;
    ;; JMP [RBX] Gadget / Stack Pivot (To restore original Control Flow Stack)
    ;;
    sub rsp, [rcx].Config.JmpRbxGadgetFrameSize
    push [rcx].Config.JmpRbxGadget

    sub rsp, [rcx].Config.AddRspXGadgetFrameSize
    push [rcx].Config.AddRspXGadget

    ;;
    ;; Set the pointer to the function to call in R11
    ;;
    mov r11, [rcx].Config.SpooFunction
    jmp Parameters
Spoof ENDP

;;
;; Set the parameters to pass to the target function
;;
Parameters PROC
    mov r12, rcx 
    mov rax, [r12].Config.NArgs
    
    ; Arg01 (rcx)
    cmp rax, 1
    jb skip_1
    mov rcx, [r12].Config.Arg01

skip_1:
    ; Arg02 (rdx)
    cmp rax, 2
    jb skip_2
    mov rdx, [r12].Config.Arg02
    
skip_2:
    ; Arg03 (r8)
    cmp rax, 3
    jb skip_3
    mov r8, [r12].Config.Arg03

skip_3:
    ; Arg04 (r9)
    cmp rax, 4
    jb skip_4
    mov r9, [r12].Config.Arg04

skip_4:
    ; Stack-based args
    lea r13, [rsp] 

    cmp rax, 5
    jb skip_5
    mov r10, [r12].Config.Arg05
    mov [r13 + 28h], r10

skip_5:
    ; Arg06
    cmp rax, 6
    jb skip_6
    mov r10, [r12].Config.Arg06
    mov [r13 + 30h], r10

skip_6:
    ; Arg07
    cmp rax, 7
    jb skip_7
    mov r10, [r12].Config.Arg07
    mov [r13 + 38h], r10

skip_7:
    ; Arg08
    cmp rax, 8
    jb skip_8
    mov r10, [r12].Config.Arg08
    mov [r13 + 40h], r10
    
skip_8:
    ; Arg09
    cmp rax, 9
    jb skip_9
    mov r10, [r12].Config.Arg09
    mov [r13 + 48h], r10

skip_9:
    ; Arg10
    cmp rax, 10
    jb skip_10
    mov r10, [r12].Config.Arg10
    mov [r13 + 50h], r10

skip_10:
    ; Arg11
    cmp rax, 11
    jb skip_11
    mov r10, [r12].Config.Arg11
    mov [r13 + 58h], r10

skip_11:
    cmp [r12].Config.IsSyscall, 1
    je ExecuteSyscall

    jmp Execute
Parameters ENDP

;;
;; Restores the original stack frame
;;
Restore PROC
    mov rsp, rbp
    pop rbx
    pop rbp
    ret
Restore ENDP

;;
;; Executes the target function
;;
Execute PROC
    jmp QWORD PTR r11
Execute ENDP

;;
;; Executes a native Windows system call using the spoofed context
;;
ExecuteSyscall PROC
    mov r10, rcx
    mov eax, [r12].Config.Ssn
    jmp QWORD PTR r11
ExecuteSyscall ENDP

END
```

对上述代码的详细解释:  

```ams
    RtlUserThreadStartAddr       DQ 1
    RtlUserThreadStartFrameSize  DQ 1
    
    BaseThreadInitThunkAddr      DQ 1
    BaseThreadInitThunkFrameSize DQ 1

    FirstFrame                   DQ 1
    SecondFrame                  DQ 1
    JmpRbxGadget                 DQ 1
    AddRspXGadget                DQ 1
```

栈内存布局示例  
```Text
高地址
┌───────────────────────────────────┐
│  RtlUserThreadStart 的栈帧         │ ← FirstFrame 指向这里
│  (局部变量、保存的寄存器等)         │
├───────────────────────────────────┤
│  保存的RBP = &SecondFrame位置      │
├───────────────────────────────────┤
│  返回地址 = RtlUserThreadStartAddr │
├───────────────────────────────────┤
│  BaseThreadInitThunk 的栈帧        │ ← SecondFrame 指向这里
│  (局部变量、参数等)                │
├───────────────────────────────────┤
│  保存的RBP = 正常系统栈RBP         │
├───────────────────────────────────┤
│  返回地址 = BaseThreadInitThunkAddr│
├───────────────────────────────────┤
│  [真正的ROP链数据]                 │
└───────────────────────────────────┘
低地址 (RSP指向这里)
```




### DQ

这个定义中的栈帧大小不是1字节，而是通过宏或计算得出的实际值。 DQ 1是汇编语言中的占位符技术，用于在特定链接阶段被替换为真实值。

DQ (Define Quad Word)：定义8字节(64位)数据,  
DQ 1  
代表占位符，用于链接时重定位  
内存内容 (16进制): 01 00 00 00 00 00 00 00

## ROP链

ROP（Return-Oriented Programming，面向返回编程）是一种在现代安全防御机制下执行任意代码的高级技术。当传统的shellcode注入被防护机制阻断时，ROP通过巧妙重用程序中已有的代码片段，实现了"用敌人的武器打败敌人"的效果。

### 传统攻击方式失效

1. DEP/NX（数据执行保护）：标记栈和堆为不可执行
2. ASLR（地址空间布局随机化）：每次运行时模块地址随机变化
3. Stack Canaries：检测栈溢出
4. CFG（控制流保护）：限制间接跳转目标

### ROP的核心突破

攻击者不依赖执行自己的代码,而是利用程序/系统DLL中已有的代码片段,通过控制执行流程将这些片段组合成恶意功能

### ROP基础：Gadgets与链式执行

#### Gadget

以ret指令结尾的短小代码序列（通常2-8条指令）,来源于程序本身、系统DLL（如ntdll.dll、kernel32.dll,功能：执行小的原子操作（如寄存器赋值、内存读写）

在现代CPU中，寄存器的大小通常与CPU的位数相关。例如，32位CPU的寄存器通常为32位（4字节），而64位CPU的寄存器通常为64位（8字节）。

```asm
; 设置第一个参数（x64调用约定）
;根据x86-64架构的硬件设计规范和指令集定义,pop rdi从rsp读取8字节到rdi寄存器,即从栈顶内存读取8字节,64位模式下RSP增加8
;POP(向高地址移动,RSP增加8),"pop rdi指令从RSP寄存器指向的内存地址读取8字节数据，将其加载到RDI寄存器中，然后将RSP寄存器的值增加8，使其指向新的栈顶位置,使栈的逻辑大小减少8字节(因为栈向低地址生长,栈底(高地址)固定,栈顶(低地址)变化),RSP增加8,逻辑大小=栈底-RSP,程序视角来看,栈中有效数据减少8字节,这些数据已转移到RDI寄存器。"
pop rdi
ret

; 设置第二、三个参数
pop rsi
pop r15
ret

; 内存写入
mov [rax], rbx
ret

; 算术运算
add rax, rbx
ret

; 间接跳转
jmp rax
ret
```

## x64架构核心寄存器详解

64位通用寄存器(8字节/64位)  

<table node="[object Object]"><thead><tr><th>寄存器</th><th>特殊用途</th><th>Windows调用约定角色</th><th>保存责任</th></tr></thead><tbody><tr><td><strong>RAX</strong></td><td>累加器，返回值</td><td>存放函数返回值</td><td>调用者保存</td></tr><tr><td><strong>RBX</strong></td><td>基址寄存器</td><td>-</td><td>被调用者保存</td></tr><tr><td><strong>RCX</strong></td><td>计数器</td><td><strong>第1参数</strong></td><td>调用者保存</td></tr><tr><td><strong>RDX</strong></td><td>数据寄存器</td><td><strong>第2参数</strong></td><td>调用者保存</td></tr><tr><td><strong>RSI</strong></td><td>源变址</td><td>-</td><td>被调用者保存</td></tr><tr><td><strong>RDI</strong></td><td>目的变址</td><td>-</td><td>被调用者保存</td></tr><tr><td><strong>RBP</strong></td><td>基址指针</td><td>栈帧基址</td><td>被调用者保存</td></tr><tr><td><strong>RSP</strong></td><td>栈指针</td><td>指向栈顶</td><td>系统管理</td></tr><tr><td><strong>R8-R11</strong></td><td>通用</td><td>R8=第3参数, R9=第4参数</td><td>调用者保存</td></tr><tr><td><strong>R12-R15</strong></td><td>通用</td><td>额外参数/临时值</td><td>被调用者保存</td></tr></tbody></table>

### RIP

RIP寄存器是x86-64架构中的指令指针寄存器，用于存储当前执行指令的下一条指令的内存地址。它的主要功能是支持位置无关代码（PIC），使得程序在不同的内存地址加载时仍能正确运行。

### pop rdi

RDI寄存器:在 x86-64 架构中，RSI 和 RDI 是两个常用的 64 位通用寄存器，主要用于函数调用参数传递和字符串/内存操作
当CPU执行pop rdi时，经历以下微操作：  

1. 取指阶段(IF)：从CS:RIP获取指令编码(0x5F)
2. 识别为POP RDI指令
3. 执行阶段(EX),生成内存地址：SS段基址 + RSP值;发出内存读请求(64位/8字节宽度)
4. 访存阶段(MEM)：从内存控制器获取8字节数据;数据通过内存总线传输到CPU
5. 写回阶段(WB)：将数据写入RDI寄存器;更新RSP = RSP + 8
对应的真实操作:  
6. CPU生成物理地址：物理地址 = SS段基址(通常为0) + RSP
7. 通过MMU(内存管理单元)转换为物理地址
8. 发出64位内存读请求到内存控制器
9. 内存子系统返回8字节数据
10. CPU将这8字节直接写入RDI寄存器的64位存储单元

**pop指令不会清除内存内容！它只是读取数据并移动RSP指针。原始内存数据保持不变，直到被新数据覆盖。**

**POP和PUSH每次都是以8字节为单位移动**

### POP操作的是指针还是数据?  

pop rdi指令操作的既是指针也是数据——它只是将8字节原始位模式从内存复制到RDI寄存器，而不关心这些位的语义含义。指针与数据的区分完全取决于程序上下文和后续指令如何使用RDI。

冯·诺依曼架构的根本特性  

1. 存储程序概念：指令和数据共享同一地址空间
2. 统一表示：内存中所有内容都是二进制位，通过上下文赋予意义
3. 无类型硬件：CPU只处理位模式，不理解高级语义

这种模糊性对ROP至关重要  
攻击者利用硬件不区分指针/数据的特性,将数据强制解释为指针，或反之,绕过类型安全检查

pop rdi操作的本质揭示了计算机系统的核心哲学："一切皆位，意义源于上下文"

理解这种双重性，是掌握底层系统安全、漏洞利用和防御技术的关键基石。在ROP攻击中，正是这种模糊性让攻击者能够：

将任意数据放入寄存器
通过精心设计的上下文，使这些数据在需要时表现为指针
最终实现控制流劫持，而无需注入新代码
这不仅是技术细节，更是现代计算安全攻防的核心战场。

## 到底什么是栈?

栈(Stack)是计算机系统中最基础、最核心的数据结构和内存管理机制，它遵循LIFO(Last-In-First-Out，后进先出)原则，是程序执行、函数调用和内存管理的基石  
栈不是程序"产生"的，而是由操作系统在创建进程/线程时预先分配的内存区域，由CPU架构提供硬件支持，由编译器生成的代码进行管理

两种操作PUSH POP:  

1. PUSH,将元素添加到栈顶
2. POP  ,移除元素并返回栈顶元素

### 栈和栈帧

栈是程序运行时的内存区域，而栈帧是栈中表示单次函数调用的逻辑单元。 就像一栋大楼(栈)由多个楼层(栈帧)组成，每个楼层有其特定的用途和布局。  

栈(Stack):线程专属的连续内存区域，遵循LIFO原则，用于存储执行上下文
栈帧(Stack Frame):栈中的一个逻辑单元，对应一次函数调用的完整上下文  

<div class="tongyi-markdown-table-wrapper" data-spm-anchor-id="5176.28103460.0.i146.358c6308QLKY4g"><table node="[object Object]"><thead><tr><th>特性</th><th>栈(Stack)</th><th>栈帧(Stack Frame)</th></tr></thead><tbody><tr><td><strong>粒度</strong></td><td>线程级</td><td>函数级</td></tr><tr><td><strong>管理者</strong></td><td>操作系统+CPU</td><td>编译器生成的代码</td></tr><tr><td><strong>指针寄存器</strong></td><td>RSP(栈指针)</td><td>RBP(基址指针)</td></tr><tr><td><strong>大小确定</strong></td><td>线程创建时设定</td><td>函数编译时计算</td></tr><tr><td><strong>对齐要求</strong></td><td>16字节对齐(入口)</td><td>16字节对齐(内部)</td></tr><tr><td><strong>生命周期</strong></td><td>线程整个生命周期</td><td>单次函数调用周期</td></tr><tr><td><strong>溢出后果</strong></td><td>程序崩溃(SEGV)</td><td>通常破坏其他栈帧</td></tr><tr><td><strong>调试命令</strong></td><td><code node="[object Object]" message="[object Object]" contentid="47de896c002a4f1eb23de4249f6454ba_0" contentstatus="finished" answeritemmodel="[object Object]">info stack</code></td><td><code node="[object Object]" message="[object Object]" contentid="47de896c002a4f1eb23de4249f6454ba_0" contentstatus="finished" answeritemmodel="[object Object]">info frame</code></td></tr></tbody></table></div>

结构关系:  

```Text
高地址
┌───────────────────────┐ ← 栈底 (固定)
│      main()栈帧        │
│  (局部变量、返回地址)   │
├───────────────────────┤
│     func1()栈帧        │
│  (局部变量、返回地址)   │
├───────────────────────┤
│     func2()栈帧        │
│  (局部变量、返回地址)   │
└───────────────────────┘ ← 栈顶/RSP (动态变化)
低地址
```

栈溢出可能会覆盖线程栈底，触发保护页,SEGV信号，程序立即终止  
栈帧级溢出,后果：覆盖相邻栈帧(返回地址、参数),利用：ROP攻击，控制流劫持

### 栈的诞生：操作系统层面

1. 进程创建时的栈分配.
2. 关键系统调用  
Linux：clone()/fork()系统调用内部调用copy_process() → dup_task_struct() → alloc_thread_stack_node()  
Windows：CreateProcess() → NtCreateThreadEx() → 内核分配栈空间  

栈内存的特性:  

1. 虚拟内存分配：仅预留地址空间，物理页按需分配
2. 向下生长标志：VM_GROWSDOWN (Linux) / MEM_TOP_DOWN (Windows)
3. 保护页：栈底下方设置不可访问页，用于检测溢出

### CPU架构：硬件支持栈操作

x86/x64架构的栈实现:  
专用寄存器：  
RSP (Stack Pointer)：永远指向栈顶  
RBP (Base Pointer)：指向当前栈帧基址  
内存区域：从高地址向低地址生长
字长对齐：64位系统中，每次Push/Pop操作8字节

RSP/ESP/SP：栈指针寄存器，所有栈操作自动更新
RBP/EBP/BP：基址指针，用于访问栈帧
SS：栈段寄存器，确定栈的内存段

专用指令集:  
CPU内置单周期栈操作指令：  

```asm
push rax  ; 硬件执行: [rsp-8] = rax; rsp -= 8
pop rdi   ; 硬件执行: rdi = [rsp]; rsp += 8
call func ; 硬件执行: push rip; jmp func
ret       ; 硬件执行: pop rip
```

栈引擎 (Stack Engine):  
现代CPU (如Intel) 有专用硬件单元处理栈操作：

分离RSP更新与内存访问
避免RSP成为性能瓶颈
支持栈指针预测 (Speculative Stack Pointer)

### 编译器：生成栈管理代码

函数调用约定  
编译器根据ABI生成栈管理代码：

```ams
// C代码
int add(int a, int b) {
    int sum = a + b;
    return sum;
}

// 编译后 (x64 Linux)
add:
    push rbp              ; 保存调用者基址
    mov rbp, rsp          ; 设置新基址
    sub rsp, 16           ; 为局部变量分配栈空间
    mov DWORD PTR [rbp-4], edi  ; 参数a
    mov DWORD PTR [rbp-8], esi  ; 参数b
    mov eax, DWORD PTR [rbp-4]
    add eax, DWORD PTR [rbp-8]
    mov DWORD PTR [rbp-12], eax ; sum = a+b
    mov eax, DWORD PTR [rbp-12] ; 返回值
    leave               ; 恢复栈: mov rsp, rbp; pop rbp
    ret                 ; 返回调用者
```

栈帧布局生成:  
编译器自动计算：

局部变量大小
保存的寄存器空间
参数传递空间
栈对齐要求 (通常16字节)

### 四、程序启动：栈的初始化

Linux程序启动流程

```ams
// 内核空间
start_thread(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp) {
    // 设置初始栈指针
    regs->sp = new_sp;
    regs->ip = new_ip;
    // ...
}

// 用户空间 (glibc)
_start() {
    // 设置初始栈
    __libc_stack_end = current_stack_pointer;
    // 解析argc/argv/envp
    argc = *(int*)__libc_stack_end;
    argv = __libc_stack_end + 8;
    envp = argv + argc*8 + 8;
    // 调用main
    exit(main(argc, argv, envp));
}
```

栈初始内容  
程序启动时栈包含：

```Text
高地址
┌───────────────┐
│  环境变量指针  │
│      ...      │
│  环境变量结束  │ (NULL)
├───────────────┤
│  参数指针      │
│      ...      │
│  参数结束      │ (NULL)
├───────────────┤
│    argc       │ (参数计数)
├───────────────┤ ← RSP (初始栈指针)
│  返回地址      │ (exit()地址，防止main返回)
└───────────────┘
低地址
```

Windows PE程序启动

```c
// Windows CRT启动代码
mainCRTStartup() {
    // 1. 初始化栈保护
    __security_init_cookie();
    
    // 2. 解析命令行
    argc = __argc;
    argv = __argv;
    
    // 3. 调用main
    exit(main(argc, argv, environ));
}
```

### 五、线程创建：独立栈分配

1. POSIX线程 (pthread)

```c
pthread_create(&thread, &attr, thread_func, arg) {
    // 1. 获取栈大小 (默认2MB或系统限制)
    size_t stack_size = attr.stacksize ?: DEFAULT_STACK_SIZE;
    
    // 2. 分配栈内存
    void* stack = mmap(NULL, stack_size,
                      PROT_READ|PROT_WRITE,
                      MAP_PRIVATE|MAP_ANONYMOUS,
                      -1, 0);
    
    // 3. 设置栈顶 (高地址)
    void* stack_top = stack + stack_size;
    
    // 4. 创建线程上下文
    ucontext_t uc;
    getcontext(&uc);
    uc.uc_stack.ss_sp = stack;
    uc.uc_stack.ss_size = stack_size;
    uc.uc_stack.ss_flags = 0;
    
    // 5. 设置入口函数
    makecontext(&uc, (void(*)())thread_func, 1, arg);
    
    // 6. 启动线程
    clone(clone_func, stack_top, flags, &uc);
}
```

windows线程

```c
CreateThread(NULL, stack_size, thread_func, arg, 0, &tid) {
    // 内核分配栈
    NTSTATUS status = NtCreateThreadEx(
        &handle,
        THREAD_ALL_ACCESS,
        NULL,
        GetCurrentProcess(),
        (PVOID)thread_func,
        arg,
        0,                // 创建标志
        stack_size,       // 堆栈大小
        0, 0, 0
    );
}
```

### 栈的生命周期

```Text
操作系统启动
    ↓
创建第一个进程 (init/systemd)
    ↓
分配初始栈 (8MB虚拟地址空间)
    ↓
加载程序 (ELF/PE)
    ↓
设置初始RSP (指向argc)
    ↓
执行_start (CRT入口)
    ↓
调用main(argc, argv, envp)
    ↓
函数调用创建栈帧
    ↓
线程创建分配新栈
    ↓
程序退出释放所有栈
```

1. 栈释放过程
正常退出：操作系统回收整个地址空间
线程结束：释放线程栈内存
异常终止：内核强制回收所有资源
